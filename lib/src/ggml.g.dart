// ignore_for_file: always_specify_types, unused_field
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// coverage:ignore-file
//
// ggml - ggml bindings for Dart language
// Author: Rainyl
// License: Apache-2.0
// Date: 2024/04/22

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_abs', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_abs(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_abs_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_abs_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

/// dst = a
/// view(dst, nb1, nb2, nb3, offset) += b
/// return dst
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Pointer<ggml_tensor>,
        ffi.Size,
        ffi.Size,
        ffi.Size,
        ffi.Size)>(symbol: 'ggml_acc', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_acc(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int nb1,
  int nb2,
  int nb3,
  int offset,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Size,
            ffi.Size,
            ffi.Size,
            ffi.Size)>(
    symbol: 'ggml_acc_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_acc_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int nb1,
  int nb2,
  int nb3,
  int offset,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_add', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_add(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_add1', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_add1(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_add1_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_add1_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int32)>(symbol: 'ggml_add_cast', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_add_cast(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int type,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_add_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_add_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

/// used in sam
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_add_rel_pos', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_add_rel_pos(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> pw,
  ffi.Pointer<ggml_tensor> ph,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_add_rel_pos_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_add_rel_pos_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> pw,
  ffi.Pointer<ggml_tensor> ph,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int,
        ffi.Int,
        ffi.Float)>(symbol: 'ggml_alibi', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_alibi(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int n_past,
  int n_head,
  double bias_max,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Float,
        ffi.Float,
        ffi.Float)>(symbol: 'ggml_arange', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_arange(
  ffi.Pointer<ggml_context> ctx,
  double start,
  double stop,
  double step,
);

@ffi.Native<
        ffi.Bool Function(ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_are_same_shape', assetId: 'package:ggml/ggml.dart')
external bool ggml_are_same_shape(
  ffi.Pointer<ggml_tensor> t0,
  ffi.Pointer<ggml_tensor> t1,
);

/// argmax along rows
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_argmax', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_argmax(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int32)>(symbol: 'ggml_argsort', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_argsort(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int order,
);

@ffi.Native<ggml_backend_buffer_t Function(ggml_backend_t, ffi.Size)>(
    symbol: 'ggml_backend_alloc_buffer', assetId: 'package:ggml/ggml.dart')
external ggml_backend_buffer_t ggml_backend_alloc_buffer(
  ggml_backend_t backend,
  int size,
);

@ffi.Native<
        ffi.Pointer<ggml_backend_buffer> Function(
            ffi.Pointer<ggml_context>, ggml_backend_t)>(
    symbol: 'ggml_backend_alloc_ctx_tensors', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_backend_buffer> ggml_backend_alloc_ctx_tensors(
  ffi.Pointer<ggml_context> ctx,
  ggml_backend_t backend,
);

/// Utils
/// Create a buffer and allocate all the tensors in a ggml_context
@ffi.Native<
        ffi.Pointer<ggml_backend_buffer> Function(
            ffi.Pointer<ggml_context>, ggml_backend_buffer_type_t)>(
    symbol: 'ggml_backend_alloc_ctx_tensors_from_buft',
    assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_backend_buffer>
    ggml_backend_alloc_ctx_tensors_from_buft(
  ffi.Pointer<ggml_context> ctx,
  ggml_backend_buffer_type_t buft,
);

@ffi.Native<ffi.Void Function(ggml_backend_buffer_t, ffi.Uint8)>(
    symbol: 'ggml_backend_buffer_clear', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_buffer_clear(
  ggml_backend_buffer_t buffer,
  int value,
);

@ffi.Native<ffi.Void Function(ggml_backend_buffer_t)>(
    symbol: 'ggml_backend_buffer_free', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_buffer_free(
  ggml_backend_buffer_t buffer,
);

@ffi.Native<ffi.Size Function(ggml_backend_buffer_t)>(
    symbol: 'ggml_backend_buffer_get_alignment',
    assetId: 'package:ggml/ggml.dart')
external int ggml_backend_buffer_get_alignment(
  ggml_backend_buffer_t buffer,
);

@ffi.Native<ffi.Size Function(ggml_backend_buffer_t, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_backend_buffer_get_alloc_size',
    assetId: 'package:ggml/ggml.dart')
external int ggml_backend_buffer_get_alloc_size(
  ggml_backend_buffer_t buffer,
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ggml_backend_buffer_t)>(
    symbol: 'ggml_backend_buffer_get_base', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Void> ggml_backend_buffer_get_base(
  ggml_backend_buffer_t buffer,
);

@ffi.Native<ffi.Size Function(ggml_backend_buffer_t)>(
    symbol: 'ggml_backend_buffer_get_max_size',
    assetId: 'package:ggml/ggml.dart')
external int ggml_backend_buffer_get_max_size(
  ggml_backend_buffer_t buffer,
);

@ffi.Native<ffi.Size Function(ggml_backend_buffer_t)>(
    symbol: 'ggml_backend_buffer_get_size', assetId: 'package:ggml/ggml.dart')
external int ggml_backend_buffer_get_size(
  ggml_backend_buffer_t buffer,
);

@ffi.Native<ggml_backend_buffer_type_t Function(ggml_backend_buffer_t)>(
    symbol: 'ggml_backend_buffer_get_type', assetId: 'package:ggml/ggml.dart')
external ggml_backend_buffer_type_t ggml_backend_buffer_get_type(
  ggml_backend_buffer_t buffer,
);

@ffi.Native<ffi.Void Function(ggml_backend_buffer_t, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_backend_buffer_init_tensor',
    assetId: 'package:ggml/ggml.dart')
external void ggml_backend_buffer_init_tensor(
  ggml_backend_buffer_t buffer,
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Bool Function(ggml_backend_buffer_t)>(
    symbol: 'ggml_backend_buffer_is_host', assetId: 'package:ggml/ggml.dart')
external bool ggml_backend_buffer_is_host(
  ggml_backend_buffer_t buffer,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ggml_backend_buffer_t)>(
    symbol: 'ggml_backend_buffer_name', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Char> ggml_backend_buffer_name(
  ggml_backend_buffer_t buffer,
);

@ffi.Native<ffi.Void Function(ggml_backend_buffer_t)>(
    symbol: 'ggml_backend_buffer_reset', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_buffer_reset(
  ggml_backend_buffer_t buffer,
);

@ffi.Native<ffi.Void Function(ggml_backend_buffer_t, ffi.Int32)>(
    symbol: 'ggml_backend_buffer_set_usage', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_buffer_set_usage(
  ggml_backend_buffer_t buffer,
  int usage,
);

@ffi.Native<
        ggml_backend_buffer_t Function(ggml_backend_buffer_type_t, ffi.Size)>(
    symbol: 'ggml_backend_buft_alloc_buffer', assetId: 'package:ggml/ggml.dart')
external ggml_backend_buffer_t ggml_backend_buft_alloc_buffer(
  ggml_backend_buffer_type_t buft,
  int size,
);

@ffi.Native<ffi.Size Function(ggml_backend_buffer_type_t)>(
    symbol: 'ggml_backend_buft_get_alignment',
    assetId: 'package:ggml/ggml.dart')
external int ggml_backend_buft_get_alignment(
  ggml_backend_buffer_type_t buft,
);

@ffi.Native<
        ffi.Size Function(
            ggml_backend_buffer_type_t, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_backend_buft_get_alloc_size',
    assetId: 'package:ggml/ggml.dart')
external int ggml_backend_buft_get_alloc_size(
  ggml_backend_buffer_type_t buft,
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Size Function(ggml_backend_buffer_type_t)>(
    symbol: 'ggml_backend_buft_get_max_size', assetId: 'package:ggml/ggml.dart')
external int ggml_backend_buft_get_max_size(
  ggml_backend_buffer_type_t buft,
);

@ffi.Native<ffi.Bool Function(ggml_backend_buffer_type_t)>(
    symbol: 'ggml_backend_buft_is_host', assetId: 'package:ggml/ggml.dart')
external bool ggml_backend_buft_is_host(
  ggml_backend_buffer_type_t buft,
);

/// buffer type
@ffi.Native<ffi.Pointer<ffi.Char> Function(ggml_backend_buffer_type_t)>(
    symbol: 'ggml_backend_buft_name', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Char> ggml_backend_buft_name(
  ggml_backend_buffer_type_t buft,
);

@ffi.Native<ffi.Bool Function(ggml_backend_buffer_type_t, ggml_backend_t)>(
    symbol: 'ggml_backend_buft_supports_backend',
    assetId: 'package:ggml/ggml.dart')
external bool ggml_backend_buft_supports_backend(
  ggml_backend_buffer_type_t buft,
  ggml_backend_t backend,
);

/// Compare the output of two backends
@ffi.Native<
        ffi.Bool Function(
            ggml_backend_t,
            ggml_backend_t,
            ffi.Pointer<ggml_cgraph>,
            ggml_backend_eval_callback,
            ffi.Pointer<ffi.Void>)>(
    symbol: 'ggml_backend_compare_graph_backend',
    assetId: 'package:ggml/ggml.dart')
external bool ggml_backend_compare_graph_backend(
  ggml_backend_t backend1,
  ggml_backend_t backend2,
  ffi.Pointer<ggml_cgraph> graph,
  ggml_backend_eval_callback callback,
  ffi.Pointer<ffi.Void> user_data,
);

/// Create a backend buffer from an existing pointer
@ffi.Native<ggml_backend_buffer_t Function(ffi.Pointer<ffi.Void>, ffi.Size)>(
    symbol: 'ggml_backend_cpu_buffer_from_ptr',
    assetId: 'package:ggml/ggml.dart')
external ggml_backend_buffer_t ggml_backend_cpu_buffer_from_ptr(
  ffi.Pointer<ffi.Void> ptr,
  int size,
);

@ffi.Native<ggml_backend_buffer_type_t Function()>(
    symbol: 'ggml_backend_cpu_buffer_type', assetId: 'package:ggml/ggml.dart')
external ggml_backend_buffer_type_t ggml_backend_cpu_buffer_type();

/// CPU backend
@ffi.Native<ggml_backend_t Function()>(
    symbol: 'ggml_backend_cpu_init', assetId: 'package:ggml/ggml.dart')
external ggml_backend_t ggml_backend_cpu_init();

@ffi.Native<
        ffi.Void Function(
            ggml_backend_t, ggml_abort_callback, ffi.Pointer<ffi.Void>)>(
    symbol: 'ggml_backend_cpu_set_abort_callback',
    assetId: 'package:ggml/ggml.dart')
external void ggml_backend_cpu_set_abort_callback(
  ggml_backend_t backend_cpu,
  ggml_abort_callback abort_callback,
  ffi.Pointer<ffi.Void> abort_callback_data,
);

@ffi.Native<ffi.Void Function(ggml_backend_t, ffi.Int)>(
    symbol: 'ggml_backend_cpu_set_n_threads', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_cpu_set_n_threads(
  ggml_backend_t backend_cpu,
  int n_threads,
);

@ffi.Native<ffi.Void Function(ggml_backend_event_t)>(
    symbol: 'ggml_backend_event_free', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_event_free(
  ggml_backend_event_t event,
);

/// events
@ffi.Native<ggml_backend_event_t Function(ggml_backend_t)>(
    symbol: 'ggml_backend_event_new', assetId: 'package:ggml/ggml.dart')
external ggml_backend_event_t ggml_backend_event_new(
  ggml_backend_t backend,
);

@ffi.Native<ffi.Void Function(ggml_backend_event_t)>(
    symbol: 'ggml_backend_event_record', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_event_record(
  ggml_backend_event_t event,
);

@ffi.Native<ffi.Void Function(ggml_backend_event_t)>(
    symbol: 'ggml_backend_event_synchronize', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_event_synchronize(
  ggml_backend_event_t event,
);

@ffi.Native<ffi.Void Function(ggml_backend_t, ggml_backend_event_t)>(
    symbol: 'ggml_backend_event_wait', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_event_wait(
  ggml_backend_t backend,
  ggml_backend_event_t event,
);

@ffi.Native<ffi.Void Function(ggml_backend_t)>(
    symbol: 'ggml_backend_free', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_free(
  ggml_backend_t backend,
);

@ffi.Native<ffi.Size Function(ggml_backend_t)>(
    symbol: 'ggml_backend_get_alignment', assetId: 'package:ggml/ggml.dart')
external int ggml_backend_get_alignment(
  ggml_backend_t backend,
);

@ffi.Native<ggml_backend_buffer_type_t Function(ggml_backend_t)>(
    symbol: 'ggml_backend_get_default_buffer_type',
    assetId: 'package:ggml/ggml.dart')
external ggml_backend_buffer_type_t ggml_backend_get_default_buffer_type(
  ggml_backend_t backend,
);

@ffi.Native<ffi.Size Function(ggml_backend_t)>(
    symbol: 'ggml_backend_get_max_size', assetId: 'package:ggml/ggml.dart')
external int ggml_backend_get_max_size(
  ggml_backend_t backend,
);

@ffi.Native<ffi.Int32 Function(ggml_backend_t, ffi.Pointer<ggml_cgraph>)>(
    symbol: 'ggml_backend_graph_compute', assetId: 'package:ggml/ggml.dart')
external int ggml_backend_graph_compute(
  ggml_backend_t backend,
  ffi.Pointer<ggml_cgraph> cgraph,
);

@ffi.Native<ffi.Int32 Function(ggml_backend_t, ffi.Pointer<ggml_cgraph>)>(
    symbol: 'ggml_backend_graph_compute_async',
    assetId: 'package:ggml/ggml.dart')
external int ggml_backend_graph_compute_async(
  ggml_backend_t backend,
  ffi.Pointer<ggml_cgraph> cgraph,
);

/// Copy a graph to a different backend
@ffi.Native<
        ggml_backend_graph_copy Function(
            ggml_backend_t, ffi.Pointer<ggml_cgraph>)>(
    symbol: 'ggml_backend_graph_copy', assetId: 'package:ggml/ggml.dart')
external ggml_backend_graph_copy ggml_backend_graph_copy1(
  ggml_backend_t backend,
  ffi.Pointer<ggml_cgraph> graph,
);

@ffi.Native<ffi.Void Function(ggml_backend_graph_copy)>(
    symbol: 'ggml_backend_graph_copy_free', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_graph_copy_free(
  ggml_backend_graph_copy copy,
);

@ffi.Native<ffi.Int32 Function(ggml_backend_t, ggml_backend_graph_plan_t)>(
    symbol: 'ggml_backend_graph_plan_compute',
    assetId: 'package:ggml/ggml.dart')
external int ggml_backend_graph_plan_compute(
  ggml_backend_t backend,
  ggml_backend_graph_plan_t plan,
);

@ffi.Native<
        ggml_backend_graph_plan_t Function(
            ggml_backend_t, ffi.Pointer<ggml_cgraph>)>(
    symbol: 'ggml_backend_graph_plan_create', assetId: 'package:ggml/ggml.dart')
external ggml_backend_graph_plan_t ggml_backend_graph_plan_create(
  ggml_backend_t backend,
  ffi.Pointer<ggml_cgraph> cgraph,
);

@ffi.Native<ffi.Void Function(ggml_backend_t, ggml_backend_graph_plan_t)>(
    symbol: 'ggml_backend_graph_plan_free', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_graph_plan_free(
  ggml_backend_t backend,
  ggml_backend_graph_plan_t plan,
);

/// Backend
@ffi.Native<ggml_guid_t Function(ggml_backend_t)>(
    symbol: 'ggml_backend_guid', assetId: 'package:ggml/ggml.dart')
external ggml_guid_t ggml_backend_guid(
  ggml_backend_t backend,
);

@ffi.Native<ffi.Bool Function(ggml_backend_t)>(
    symbol: 'ggml_backend_is_cpu', assetId: 'package:ggml/ggml.dart')
external bool ggml_backend_is_cpu(
  ggml_backend_t backend,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ggml_backend_t)>(
    symbol: 'ggml_backend_name', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Char> ggml_backend_name(
  ggml_backend_t backend,
);

@ffi.Native<ffi.Bool Function(ggml_backend_t, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_backend_offload_op', assetId: 'package:ggml/ggml.dart')
external bool ggml_backend_offload_op(
  ggml_backend_t backend,
  ffi.Pointer<ggml_tensor> op,
);

@ffi.Native<ggml_backend_buffer_t Function(ffi.Size, ffi.Size)>(
    symbol: 'ggml_backend_reg_alloc_buffer', assetId: 'package:ggml/ggml.dart')
external ggml_backend_buffer_t ggml_backend_reg_alloc_buffer(
  int i,
  int size,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'ggml_backend_reg_find_by_name', assetId: 'package:ggml/ggml.dart')
external int ggml_backend_reg_find_by_name(
  ffi.Pointer<ffi.Char> name,
);

/// The backend registry is a registry of all the available backends, and allows initializing backends in a generic way
@ffi.Native<ffi.Size Function()>(
    symbol: 'ggml_backend_reg_get_count', assetId: 'package:ggml/ggml.dart')
external int ggml_backend_reg_get_count();

@ffi.Native<ggml_backend_buffer_type_t Function(ffi.Size)>(
    symbol: 'ggml_backend_reg_get_default_buffer_type',
    assetId: 'package:ggml/ggml.dart')
external ggml_backend_buffer_type_t ggml_backend_reg_get_default_buffer_type(
  int i,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Size)>(
    symbol: 'ggml_backend_reg_get_name', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Char> ggml_backend_reg_get_name(
  int i,
);

@ffi.Native<ggml_backend_t Function(ffi.Size, ffi.Pointer<ffi.Char>)>(
    symbol: 'ggml_backend_reg_init_backend', assetId: 'package:ggml/ggml.dart')
external ggml_backend_t ggml_backend_reg_init_backend(
  int i,
  ffi.Pointer<ffi.Char> params,
);

@ffi.Native<ggml_backend_t Function(ffi.Pointer<ffi.Char>)>(
    symbol: 'ggml_backend_reg_init_backend_from_str',
    assetId: 'package:ggml/ggml.dart')
external ggml_backend_t ggml_backend_reg_init_backend_from_str(
  ffi.Pointer<ffi.Char> backend_str,
);

/// Allocate and compute graph on the backend scheduler
@ffi.Native<ffi.Bool Function(ggml_backend_sched_t, ffi.Pointer<ggml_cgraph>)>(
    symbol: 'ggml_backend_sched_alloc_graph', assetId: 'package:ggml/ggml.dart')
external bool ggml_backend_sched_alloc_graph(
  ggml_backend_sched_t sched,
  ffi.Pointer<ggml_cgraph> graph,
);

@ffi.Native<ffi.Void Function(ggml_backend_sched_t)>(
    symbol: 'ggml_backend_sched_free', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_sched_free(
  ggml_backend_sched_t sched,
);

@ffi.Native<ffi.Size Function(ggml_backend_sched_t, ggml_backend_t)>(
    symbol: 'ggml_backend_sched_get_buffer_size',
    assetId: 'package:ggml/ggml.dart')
external int ggml_backend_sched_get_buffer_size(
  ggml_backend_sched_t sched,
  ggml_backend_t backend,
);

@ffi.Native<ffi.Int Function(ggml_backend_sched_t)>(
    symbol: 'ggml_backend_sched_get_n_copies',
    assetId: 'package:ggml/ggml.dart')
external int ggml_backend_sched_get_n_copies(
  ggml_backend_sched_t sched,
);

/// Get the number of splits of the last graph
@ffi.Native<ffi.Int Function(ggml_backend_sched_t)>(
    symbol: 'ggml_backend_sched_get_n_splits',
    assetId: 'package:ggml/ggml.dart')
external int ggml_backend_sched_get_n_splits(
  ggml_backend_sched_t sched,
);

@ffi.Native<
        ggml_backend_t Function(
            ggml_backend_sched_t, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_backend_sched_get_tensor_backend',
    assetId: 'package:ggml/ggml.dart')
external ggml_backend_t ggml_backend_sched_get_tensor_backend(
  ggml_backend_sched_t sched,
  ffi.Pointer<ggml_tensor> node,
);

@ffi.Native<ffi.Int32 Function(ggml_backend_sched_t, ffi.Pointer<ggml_cgraph>)>(
    symbol: 'ggml_backend_sched_graph_compute',
    assetId: 'package:ggml/ggml.dart')
external int ggml_backend_sched_graph_compute(
  ggml_backend_sched_t sched,
  ffi.Pointer<ggml_cgraph> graph,
);

@ffi.Native<ffi.Int32 Function(ggml_backend_sched_t, ffi.Pointer<ggml_cgraph>)>(
    symbol: 'ggml_backend_sched_graph_compute_async',
    assetId: 'package:ggml/ggml.dart')
external int ggml_backend_sched_graph_compute_async(
  ggml_backend_sched_t sched,
  ffi.Pointer<ggml_cgraph> graph,
);

/// Initialize a backend scheduler
@ffi.Native<
        ggml_backend_sched_t Function(
            ffi.Pointer<ggml_backend_t>,
            ffi.Pointer<ggml_backend_buffer_type_t>,
            ffi.Int,
            ffi.Size,
            ffi.Bool)>(
    symbol: 'ggml_backend_sched_new', assetId: 'package:ggml/ggml.dart')
external ggml_backend_sched_t ggml_backend_sched_new(
  ffi.Pointer<ggml_backend_t> backends,
  ffi.Pointer<ggml_backend_buffer_type_t> bufts,
  int n_backends,
  int graph_size,
  bool parallel,
);

/// Initialize backend buffers from a measure graph
@ffi.Native<ffi.Bool Function(ggml_backend_sched_t, ffi.Pointer<ggml_cgraph>)>(
    symbol: 'ggml_backend_sched_reserve', assetId: 'package:ggml/ggml.dart')
external bool ggml_backend_sched_reserve(
  ggml_backend_sched_t sched,
  ffi.Pointer<ggml_cgraph> measure_graph,
);

/// Reset all assignments and allocators - must be called before changing the node backends
@ffi.Native<ffi.Void Function(ggml_backend_sched_t)>(
    symbol: 'ggml_backend_sched_reset', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_sched_reset(
  ggml_backend_sched_t sched,
);

/// Set a callback to be called for each resulting node during graph compute
@ffi.Native<
        ffi.Void Function(ggml_backend_sched_t,
            ggml_backend_sched_eval_callback, ffi.Pointer<ffi.Void>)>(
    symbol: 'ggml_backend_sched_set_eval_callback',
    assetId: 'package:ggml/ggml.dart')
external void ggml_backend_sched_set_eval_callback(
  ggml_backend_sched_t sched,
  ggml_backend_sched_eval_callback callback,
  ffi.Pointer<ffi.Void> user_data,
);

@ffi.Native<
        ffi.Void Function(
            ggml_backend_sched_t, ffi.Pointer<ggml_tensor>, ggml_backend_t)>(
    symbol: 'ggml_backend_sched_set_tensor_backend',
    assetId: 'package:ggml/ggml.dart')
external void ggml_backend_sched_set_tensor_backend(
  ggml_backend_sched_t sched,
  ffi.Pointer<ggml_tensor> node,
  ggml_backend_t backend,
);

@ffi.Native<ffi.Void Function(ggml_backend_sched_t)>(
    symbol: 'ggml_backend_sched_synchronize', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_sched_synchronize(
  ggml_backend_sched_t sched,
);

@ffi.Native<ffi.Bool Function(ggml_backend_t, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_backend_supports_op', assetId: 'package:ggml/ggml.dart')
external bool ggml_backend_supports_op(
  ggml_backend_t backend,
  ffi.Pointer<ggml_tensor> op,
);

@ffi.Native<ffi.Void Function(ggml_backend_t)>(
    symbol: 'ggml_backend_synchronize', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_synchronize(
  ggml_backend_t backend,
);

/// Tensor initialization
@ffi.Native<
        ffi.Void Function(ggml_backend_buffer_t, ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ffi.Void>)>(
    symbol: 'ggml_backend_tensor_alloc', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_tensor_alloc(
  ggml_backend_buffer_t buffer,
  ffi.Pointer<ggml_tensor> tensor,
  ffi.Pointer<ffi.Void> addr,
);

/// tensor copy between different backends
@ffi.Native<
        ffi.Void Function(ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_backend_tensor_copy', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_tensor_copy(
  ffi.Pointer<ggml_tensor> src,
  ffi.Pointer<ggml_tensor> dst,
);

/// asynchronous copy
/// the copy is performed after all the currently queued operations in backend_src
/// backend_dst will wait for the copy to complete before performing other operations
/// automatic fallback to sync copy if async is not supported
@ffi.Native<
        ffi.Void Function(ggml_backend_t, ggml_backend_t,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_backend_tensor_copy_async', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_tensor_copy_async(
  ggml_backend_t backend_src,
  ggml_backend_t backend_dst,
  ffi.Pointer<ggml_tensor> src,
  ffi.Pointer<ggml_tensor> dst,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<ggml_tensor>, ffi.Pointer<ffi.Void>,
            ffi.Size, ffi.Size)>(
    symbol: 'ggml_backend_tensor_get', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_tensor_get(
  ffi.Pointer<ggml_tensor> tensor,
  ffi.Pointer<ffi.Void> data,
  int offset,
  int size,
);

@ffi.Native<
        ffi.Void Function(ggml_backend_t, ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size)>(
    symbol: 'ggml_backend_tensor_get_async', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_tensor_get_async(
  ggml_backend_t backend,
  ffi.Pointer<ggml_tensor> tensor,
  ffi.Pointer<ffi.Void> data,
  int offset,
  int size,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<ggml_tensor>, ffi.Pointer<ffi.Void>,
            ffi.Size, ffi.Size)>(
    symbol: 'ggml_backend_tensor_set', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_tensor_set(
  ffi.Pointer<ggml_tensor> tensor,
  ffi.Pointer<ffi.Void> data,
  int offset,
  int size,
);

@ffi.Native<
        ffi.Void Function(ggml_backend_t, ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size)>(
    symbol: 'ggml_backend_tensor_set_async', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_tensor_set_async(
  ggml_backend_t backend,
  ffi.Pointer<ggml_tensor> tensor,
  ffi.Pointer<ffi.Void> data,
  int offset,
  int size,
);

@ffi.Native<ffi.Void Function(ggml_backend_buffer_t, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_backend_view_init', assetId: 'package:ggml/ggml.dart')
external void ggml_backend_view_init(
  ggml_backend_buffer_t buffer,
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Int Function(ffi.Int32)>(
    symbol: 'ggml_blck_size', assetId: 'package:ggml/ggml.dart')
external int ggml_blck_size(
  int type,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<ggml_context>, ffi.Pointer<ggml_cgraph>,
            ffi.Pointer<ggml_cgraph>, ffi.Bool)>(
    symbol: 'ggml_build_backward_expand', assetId: 'package:ggml/ggml.dart')
external void ggml_build_backward_expand(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_cgraph> gf,
  ffi.Pointer<ggml_cgraph> gb,
  bool keep,
);

/// build gradient checkpointing backward graph gb for gf using provided checkpoints
/// gb_tmp will contain original backward graph with rewritten backward process nodes,
/// but without the second forward pass nodes.
@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_cgraph>,
            ffi.Pointer<ggml_cgraph>,
            ffi.Pointer<ggml_cgraph>,
            ffi.Pointer<ffi.Pointer<ggml_tensor>>,
            ffi.Int)>(
    symbol: 'ggml_build_backward_gradient_checkpointing',
    assetId: 'package:ggml/ggml.dart')
external void ggml_build_backward_gradient_checkpointing(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_cgraph> gf,
  ffi.Pointer<ggml_cgraph> gb,
  ffi.Pointer<ggml_cgraph> gb_tmp,
  ffi.Pointer<ffi.Pointer<ggml_tensor>> checkpoints,
  int n_checkpoints,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<ggml_cgraph>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_build_forward_expand', assetId: 'package:ggml/ggml.dart')
external void ggml_build_forward_expand(
  ffi.Pointer<ggml_cgraph> cgraph,
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int32)>(symbol: 'ggml_cast', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_cast(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int type,
);

/// clamp
/// in-place, returns view(a)
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Float,
        ffi.Float)>(symbol: 'ggml_clamp', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_clamp(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  double min,
  double max,
);

/// concat a and b on dim 2
/// used in stable-diffusion
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_concat', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_concat(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

/// make contiguous
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_cont', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_cont(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

/// make contiguous, with new shape
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int64)>(symbol: 'ggml_cont_1d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_cont_1d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int ne0,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int64,
        ffi.Int64)>(symbol: 'ggml_cont_2d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_cont_2d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int ne0,
  int ne1,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int64,
        ffi.Int64,
        ffi.Int64)>(symbol: 'ggml_cont_3d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_cont_3d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int ne0,
  int ne1,
  int ne2,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int64,
        ffi.Int64,
        ffi.Int64,
        ffi.Int64)>(symbol: 'ggml_cont_4d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_cont_4d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int ne0,
  int ne1,
  int ne2,
  int ne3,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int,
        ffi.Int,
        ffi.Int)>(symbol: 'ggml_conv_1d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_conv_1d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int s0,
  int p0,
  int d0,
);

/// conv_1d with padding = half
/// alias for ggml_conv_1d(a, b, s, a->ne[0]/2, d)
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int,
        ffi.Int)>(symbol: 'ggml_conv_1d_ph', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_conv_1d_ph(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int s,
  int d,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        ffi.Int)>(symbol: 'ggml_conv_2d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_conv_2d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int s0,
  int s1,
  int p0,
  int p1,
  int d0,
  int d1,
);

/// kernel size is a->ne[0] x a->ne[1]
/// stride is 1
/// padding is half
/// example:
/// a:      3    3    256  256
/// b:     64   64    256    1
/// res:   64   64    256    1
/// used in sam
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_conv_2d_s1_ph', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_conv_2d_s1_ph(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

/// kernel size is a->ne[0] x a->ne[1]
/// stride is equal to kernel size
/// padding is zero
/// example:
/// a:     16   16    3  768
/// b:   1024 1024    3    1
/// res:   64   64  768    1
/// used in sam
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_conv_2d_sk_p0', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_conv_2d_sk_p0(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int)>(
    symbol: 'ggml_conv_depthwise_2d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_conv_depthwise_2d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int s0,
  int s1,
  int p0,
  int p1,
  int d0,
  int d1,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Int,
            ffi.Int,
            ffi.Int)>(
    symbol: 'ggml_conv_transpose_1d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_conv_transpose_1d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int s0,
  int p0,
  int d0,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>, ffi.Int)>(
    symbol: 'ggml_conv_transpose_2d_p0', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_conv_transpose_2d_p0(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int stride,
);

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_arm_fma', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_arm_fma();

/// system info
@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_avx', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_avx();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_avx2', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_avx2();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_avx512', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_avx512();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_avx512_vbmi', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_avx512_vbmi();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_avx512_vnni', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_avx512_vnni();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_avx_vnni', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_avx_vnni();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_blas', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_blas();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_clblast', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_clblast();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_cuda', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_cuda();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_f16c', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_f16c();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_fma', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_fma();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_fp16_va', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_fp16_va();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_gpublas', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_gpublas();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_kompute', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_kompute();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_matmul_int8', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_matmul_int8();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_metal', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_metal();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_neon', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_neon();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_sse3', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_sse3();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_ssse3', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_ssse3();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_sycl', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_sycl();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_vsx', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_vsx();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_vulkan', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_vulkan();

@ffi.Native<ffi.Int Function()>(
    symbol: 'ggml_cpu_has_wasm_simd', assetId: 'package:ggml/ggml.dart')
external int ggml_cpu_has_wasm_simd();

/// a -> b, return view(b)
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_cpy', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_cpy(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

/// loss function
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_cross_entropy_loss', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_cross_entropy_loss(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_cross_entropy_loss_back', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_cross_entropy_loss_back(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  ffi.Pointer<ggml_tensor> c,
);

@ffi.Native<ffi.Int64 Function()>(
    symbol: 'ggml_cycles', assetId: 'package:ggml/ggml.dart')
external int ggml_cycles();

@ffi.Native<ffi.Int64 Function()>(
    symbol: 'ggml_cycles_per_ms', assetId: 'package:ggml/ggml.dart')
external int ggml_cycles_per_ms();

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_diag', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_diag(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

/// set elements above the diagonal to -INF
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>, ffi.Int)>(
    symbol: 'ggml_diag_mask_inf', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_diag_mask_inf(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int n_past,
);

/// in-place, returns view(a)
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>, ffi.Int)>(
    symbol: 'ggml_diag_mask_inf_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_diag_mask_inf_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int n_past,
);

/// set elements above the diagonal to 0
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>, ffi.Int)>(
    symbol: 'ggml_diag_mask_zero', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_diag_mask_zero(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int n_past,
);

/// in-place, returns view(a)
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>, ffi.Int)>(
    symbol: 'ggml_diag_mask_zero_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_diag_mask_zero_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int n_past,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_div', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_div(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_div_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_div_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

/// operations on tensors with backpropagation
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_dup', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_dup(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

/// in-place, returns view(a)
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_dup_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_dup_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_dup_tensor', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_dup_tensor(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> src,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_element_size', assetId: 'package:ggml/ggml.dart')
external int ggml_element_size(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_elu', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_elu(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_elu_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_elu_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Pointer<ggml_tensor>,
        ffi.Pointer<ggml_tensor>,
        ffi.Bool)>(symbol: 'ggml_flash_attn', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_flash_attn(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> q,
  ffi.Pointer<ggml_tensor> k,
  ffi.Pointer<ggml_tensor> v,
  bool masked,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Bool)>(
    symbol: 'ggml_flash_attn_back', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_flash_attn_back(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> q,
  ffi.Pointer<ggml_tensor> k,
  ffi.Pointer<ggml_tensor> v,
  ffi.Pointer<ggml_tensor> d,
  bool masked,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_flash_ff', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_flash_ff(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b0,
  ffi.Pointer<ggml_tensor> b1,
  ffi.Pointer<ggml_tensor> c0,
  ffi.Pointer<ggml_tensor> c1,
);

/// accepts a UTF-8 path, even on Windows
@ffi.Native<
        ffi.Pointer<FILE> Function(
            ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>(
    symbol: 'ggml_fopen', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<FILE> ggml_fopen(
  ffi.Pointer<ffi.Char> fname,
  ffi.Pointer<ffi.Char> mode,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ffi.Char>)>(
    symbol: 'ggml_format_name', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_format_name(
  ffi.Pointer<ggml_tensor> tensor,
  ffi.Pointer<ffi.Char> fmt,
);

/// convert FP16 <-> FP32
@ffi.Native<ffi.Float Function(ggml_fp16_t)>(
    symbol: 'ggml_fp16_to_fp32', assetId: 'package:ggml/ggml.dart')
external double ggml_fp16_to_fp32(
  int x,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<ggml_fp16_t>, ffi.Pointer<ffi.Float>, ffi.Int64)>(
    symbol: 'ggml_fp16_to_fp32_row', assetId: 'package:ggml/ggml.dart')
external void ggml_fp16_to_fp32_row(
  ffi.Pointer<ggml_fp16_t> x,
  ffi.Pointer<ffi.Float> y,
  int n,
);

@ffi.Native<ggml_fp16_t Function(ffi.Float)>(
    symbol: 'ggml_fp32_to_fp16', assetId: 'package:ggml/ggml.dart')
external int ggml_fp32_to_fp16(
  double x,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<ffi.Float>, ffi.Pointer<ggml_fp16_t>, ffi.Int64)>(
    symbol: 'ggml_fp32_to_fp16_row', assetId: 'package:ggml/ggml.dart')
external void ggml_fp32_to_fp16_row(
  ffi.Pointer<ffi.Float> x,
  ffi.Pointer<ggml_fp16_t> y,
  int n,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ggml_context>)>(
    symbol: 'ggml_free', assetId: 'package:ggml/ggml.dart')
external void ggml_free(
  ffi.Pointer<ggml_context> ctx,
);

/// TODO: temporary until model loading of ggml examples is refactored
@ffi.Native<ffi.Int32 Function(ffi.Int32)>(
    symbol: 'ggml_ftype_to_ggml_type', assetId: 'package:ggml/ggml.dart')
external int ggml_ftype_to_ggml_type(
  int ftype,
);

/// automatic reallocation if the topology changes when using a single buffer
/// returns false if using multiple buffers and a re-allocation is needed (call ggml_gallocr_reserve_n first to set the node buffers)
@ffi.Native<ffi.Bool Function(ggml_gallocr_t, ffi.Pointer<ggml_cgraph>)>(
    symbol: 'ggml_gallocr_alloc_graph', assetId: 'package:ggml/ggml.dart')
external bool ggml_gallocr_alloc_graph(
  ggml_gallocr_t galloc,
  ffi.Pointer<ggml_cgraph> graph,
);

@ffi.Native<ffi.Void Function(ggml_gallocr_t)>(
    symbol: 'ggml_gallocr_free', assetId: 'package:ggml/ggml.dart')
external void ggml_gallocr_free(
  ggml_gallocr_t galloc,
);

@ffi.Native<ffi.Size Function(ggml_gallocr_t, ffi.Int)>(
    symbol: 'ggml_gallocr_get_buffer_size', assetId: 'package:ggml/ggml.dart')
external int ggml_gallocr_get_buffer_size(
  ggml_gallocr_t galloc,
  int buffer_id,
);

@ffi.Native<ggml_gallocr_t Function(ggml_backend_buffer_type_t)>(
    symbol: 'ggml_gallocr_new', assetId: 'package:ggml/ggml.dart')
external ggml_gallocr_t ggml_gallocr_new(
  ggml_backend_buffer_type_t buft,
);

@ffi.Native<
        ggml_gallocr_t Function(
            ffi.Pointer<ggml_backend_buffer_type_t>, ffi.Int)>(
    symbol: 'ggml_gallocr_new_n', assetId: 'package:ggml/ggml.dart')
external ggml_gallocr_t ggml_gallocr_new_n(
  ffi.Pointer<ggml_backend_buffer_type_t> bufts,
  int n_bufs,
);

/// pre-allocate buffers from a measure graph - does not allocate or modify the graph
/// call with a worst-case graph to avoid buffer reallocations
/// not strictly required for single buffer usage: ggml_gallocr_alloc_graph will reallocate the buffers automatically if needed
/// returns false if the buffer allocation failed
@ffi.Native<ffi.Bool Function(ggml_gallocr_t, ffi.Pointer<ggml_cgraph>)>(
    symbol: 'ggml_gallocr_reserve', assetId: 'package:ggml/ggml.dart')
external bool ggml_gallocr_reserve(
  ggml_gallocr_t galloc,
  ffi.Pointer<ggml_cgraph> graph,
);

@ffi.Native<
        ffi.Bool Function(ggml_gallocr_t, ffi.Pointer<ggml_cgraph>,
            ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>(
    symbol: 'ggml_gallocr_reserve_n', assetId: 'package:ggml/ggml.dart')
external bool ggml_gallocr_reserve_n(
  ggml_gallocr_t galloc,
  ffi.Pointer<ggml_cgraph> graph,
  ffi.Pointer<ffi.Int> node_buffer_ids,
  ffi.Pointer<ffi.Int> leaf_buffer_ids,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_gelu', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_gelu(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_gelu_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_gelu_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_gelu_quick', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_gelu_quick(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_gelu_quick_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_gelu_quick_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_get_data', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Void> ggml_get_data(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Pointer<ffi.Float> Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_get_data_f32', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Float> ggml_get_data_f32(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Float Function(ffi.Pointer<ggml_tensor>, ffi.Int)>(
    symbol: 'ggml_get_f32_1d', assetId: 'package:ggml/ggml.dart')
external double ggml_get_f32_1d(
  ffi.Pointer<ggml_tensor> tensor,
  int i,
);

@ffi.Native<
    ffi.Float Function(ffi.Pointer<ggml_tensor>, ffi.Int, ffi.Int, ffi.Int,
        ffi.Int)>(symbol: 'ggml_get_f32_nd', assetId: 'package:ggml/ggml.dart')
external double ggml_get_f32_nd(
  ffi.Pointer<ggml_tensor> tensor,
  int i0,
  int i1,
  int i2,
  int i3,
);

/// Context tensor enumeration and lookup
@ffi.Native<ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>)>(
    symbol: 'ggml_get_first_tensor', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_get_first_tensor(
  ffi.Pointer<ggml_context> ctx,
);

@ffi.Native<ffi.Int32 Function(ffi.Pointer<ggml_tensor>, ffi.Int)>(
    symbol: 'ggml_get_i32_1d', assetId: 'package:ggml/ggml.dart')
external int ggml_get_i32_1d(
  ffi.Pointer<ggml_tensor> tensor,
  int i,
);

@ffi.Native<
    ffi.Int32 Function(ffi.Pointer<ggml_tensor>, ffi.Int, ffi.Int, ffi.Int,
        ffi.Int)>(symbol: 'ggml_get_i32_nd', assetId: 'package:ggml/ggml.dart')
external int ggml_get_i32_nd(
  ffi.Pointer<ggml_tensor> tensor,
  int i0,
  int i1,
  int i2,
  int i3,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<ggml_context>)>(
    symbol: 'ggml_get_max_tensor_size', assetId: 'package:ggml/ggml.dart')
external int ggml_get_max_tensor_size(
  ffi.Pointer<ggml_context> ctx,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ggml_context>)>(
    symbol: 'ggml_get_mem_buffer', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Void> ggml_get_mem_buffer(
  ffi.Pointer<ggml_context> ctx,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<ggml_context>)>(
    symbol: 'ggml_get_mem_size', assetId: 'package:ggml/ggml.dart')
external int ggml_get_mem_size(
  ffi.Pointer<ggml_context> ctx,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_get_name', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Char> ggml_get_name(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_get_next_tensor', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_get_next_tensor(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<ggml_context>)>(
    symbol: 'ggml_get_no_alloc', assetId: 'package:ggml/ggml.dart')
external bool ggml_get_no_alloc(
  ffi.Pointer<ggml_context> ctx,
);

/// used in sam
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int,
        ffi.Int)>(symbol: 'ggml_get_rel_pos', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_get_rel_pos(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int qh,
  int kh,
);

/// supports 3D: a->ne[2] == b->ne[1]
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_get_rows', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_get_rows(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_get_rows_back', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_get_rows_back(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  ffi.Pointer<ggml_tensor> c,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ffi.Char>)>(
    symbol: 'ggml_get_tensor', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_get_tensor(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ffi.Char> name,
);

@ffi.Native<ffi.Int32 Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_get_unary_op', assetId: 'package:ggml/ggml.dart')
external int ggml_get_unary_op(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ggml_cgraph>)>(
    symbol: 'ggml_graph_clear', assetId: 'package:ggml/ggml.dart')
external void ggml_graph_clear(
  ffi.Pointer<ggml_cgraph> cgraph,
);

@ffi.Native<
        ffi.Int32 Function(ffi.Pointer<ggml_cgraph>, ffi.Pointer<ggml_cplan>)>(
    symbol: 'ggml_graph_compute', assetId: 'package:ggml/ggml.dart')
external int ggml_graph_compute(
  ffi.Pointer<ggml_cgraph> cgraph,
  ffi.Pointer<ggml_cplan> cplan,
);

/// same as ggml_graph_compute() but the work data is allocated as a part of the context
/// note: the drawback of this API is that you must have ensured that the context has enough memory for the work data
@ffi.Native<
        ffi.Int32 Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_cgraph>, ffi.Int)>(
    symbol: 'ggml_graph_compute_with_ctx', assetId: 'package:ggml/ggml.dart')
external int ggml_graph_compute_with_ctx(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_cgraph> cgraph,
  int n_threads,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<ggml_cgraph>, ffi.Pointer<ggml_cgraph>)>(
    symbol: 'ggml_graph_cpy', assetId: 'package:ggml/ggml.dart')
external void ggml_graph_cpy(
  ffi.Pointer<ggml_cgraph> src,
  ffi.Pointer<ggml_cgraph> dst,
);

/// dump the graph into a file using the dot format
@ffi.Native<
        ffi.Void Function(ffi.Pointer<ggml_cgraph>, ffi.Pointer<ggml_cgraph>,
            ffi.Pointer<ffi.Char>)>(
    symbol: 'ggml_graph_dump_dot', assetId: 'package:ggml/ggml.dart')
external void ggml_graph_dump_dot(
  ffi.Pointer<ggml_cgraph> gb,
  ffi.Pointer<ggml_cgraph> gf,
  ffi.Pointer<ffi.Char> filename,
);

@ffi.Native<
        ffi.Pointer<ggml_cgraph> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_cgraph>)>(
    symbol: 'ggml_graph_dup', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_cgraph> ggml_graph_dup(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_cgraph> cgraph,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ggml_cgraph>, ffi.Pointer<ffi.Char>)>(
    symbol: 'ggml_graph_export', assetId: 'package:ggml/ggml.dart')
external void ggml_graph_export(
  ffi.Pointer<ggml_cgraph> cgraph,
  ffi.Pointer<ffi.Char> fname,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_cgraph>, ffi.Pointer<ffi.Char>)>(
    symbol: 'ggml_graph_get_tensor', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_graph_get_tensor(
  ffi.Pointer<ggml_cgraph> cgraph,
  ffi.Pointer<ffi.Char> name,
);

@ffi.Native<
        ffi.Pointer<ggml_cgraph> Function(
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Pointer<ggml_context>>,
            ffi.Pointer<ffi.Pointer<ggml_context>>)>(
    symbol: 'ggml_graph_import', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_cgraph> ggml_graph_import(
  ffi.Pointer<ffi.Char> fname,
  ffi.Pointer<ffi.Pointer<ggml_context>> ctx_data,
  ffi.Pointer<ffi.Pointer<ggml_context>> ctx_eval,
);

@ffi.Native<ffi.Size Function()>(
    symbol: 'ggml_graph_overhead', assetId: 'package:ggml/ggml.dart')
external int ggml_graph_overhead();

@ffi.Native<ffi.Size Function(ffi.Size, ffi.Bool)>(
    symbol: 'ggml_graph_overhead_custom', assetId: 'package:ggml/ggml.dart')
external int ggml_graph_overhead_custom(
  int size,
  bool grads,
);

/// ggml_graph_plan() has to be called before ggml_graph_compute()
/// when plan.work_size > 0, caller must allocate memory for plan.work_data
@ffi.Native<ggml_cplan Function(ffi.Pointer<ggml_cgraph>, ffi.Int)>(
    symbol: 'ggml_graph_plan', assetId: 'package:ggml/ggml.dart')
external ggml_cplan ggml_graph_plan(
  ffi.Pointer<ggml_cgraph> cgraph,
  int n_threads,
);

/// print info and performance information for the graph
@ffi.Native<ffi.Void Function(ffi.Pointer<ggml_cgraph>)>(
    symbol: 'ggml_graph_print', assetId: 'package:ggml/ggml.dart')
external void ggml_graph_print(
  ffi.Pointer<ggml_cgraph> cgraph,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ggml_cgraph>)>(
    symbol: 'ggml_graph_reset', assetId: 'package:ggml/ggml.dart')
external void ggml_graph_reset(
  ffi.Pointer<ggml_cgraph> cgraph,
);

@ffi.Native<ggml_cgraph Function(ffi.Pointer<ggml_cgraph>, ffi.Int, ffi.Int)>(
    symbol: 'ggml_graph_view', assetId: 'package:ggml/ggml.dart')
external ggml_cgraph ggml_graph_view(
  ffi.Pointer<ggml_cgraph> cgraph,
  int i0,
  int i1,
);

/// group normalize along ne0*ne1*n_groups
/// used in stable-diffusion
/// TODO: eps is hardcoded to 1e-6 for now
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int)>(symbol: 'ggml_group_norm', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_group_norm(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int n_groups,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>, ffi.Int)>(
    symbol: 'ggml_group_norm_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_group_norm_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int n_groups,
);

@ffi.Native<ffi.Bool Function(ggml_guid_t, ggml_guid_t)>(
    symbol: 'ggml_guid_matches', assetId: 'package:ggml/ggml.dart')
external bool ggml_guid_matches(
  ggml_guid_t guid_a,
  ggml_guid_t guid_b,
);

/// hardsigmoid(x) = relu6(x + 3) / 6
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_hardsigmoid', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_hardsigmoid(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

/// hardswish(x) = x * relu6(x + 3) / 6
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_hardswish', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_hardswish(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        ffi.Bool,
        ffi.Int32)>(symbol: 'ggml_im2col', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_im2col(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int s0,
  int s1,
  int p0,
  int p1,
  int d0,
  int d1,
  bool is_2D,
  int dst_type,
);

/// main
@ffi.Native<ffi.Pointer<ggml_context> Function(ggml_init_params)>(
    symbol: 'ggml_init', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_context> ggml_init(
  ggml_init_params params,
);

@ffi.Native<ggml_type_traits_t Function(ffi.Int32)>(
    symbol: 'ggml_internal_get_type_traits', assetId: 'package:ggml/ggml.dart')
external ggml_type_traits_t ggml_internal_get_type_traits(
  int type,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_is_3d', assetId: 'package:ggml/ggml.dart')
external bool ggml_is_3d(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_is_contiguous', assetId: 'package:ggml/ggml.dart')
external bool ggml_is_contiguous(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_is_empty', assetId: 'package:ggml/ggml.dart')
external bool ggml_is_empty(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_is_matrix', assetId: 'package:ggml/ggml.dart')
external bool ggml_is_matrix(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Bool Function()>(
    symbol: 'ggml_is_numa', assetId: 'package:ggml/ggml.dart')
external bool ggml_is_numa();

@ffi.Native<ffi.Bool Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_is_permuted', assetId: 'package:ggml/ggml.dart')
external bool ggml_is_permuted(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Bool Function(ffi.Int32)>(
    symbol: 'ggml_is_quantized', assetId: 'package:ggml/ggml.dart')
external bool ggml_is_quantized(
  int type,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_is_scalar', assetId: 'package:ggml/ggml.dart')
external bool ggml_is_scalar(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_is_transposed', assetId: 'package:ggml/ggml.dart')
external bool ggml_is_transposed(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_is_vector', assetId: 'package:ggml/ggml.dart')
external bool ggml_is_vector(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Float,
        ffi.Bool)>(symbol: 'ggml_leaky_relu', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_leaky_relu(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  double negative_slope,
  bool inplace,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_log', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_log(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_log_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_log_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ggml_binary_op_f32_t)>(
    symbol: 'ggml_map_binary_f32', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_map_binary_f32(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  ggml_binary_op_f32_t fun,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ggml_binary_op_f32_t)>(
    symbol: 'ggml_map_binary_inplace_f32', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_map_binary_inplace_f32(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  ggml_binary_op_f32_t fun,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ggml_custom1_op_t,
            ffi.Int,
            ffi.Pointer<ffi.Void>)>(
    symbol: 'ggml_map_custom1', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_map_custom1(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ggml_custom1_op_t fun,
  int n_tasks,
  ffi.Pointer<ffi.Void> userdata,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ggml_custom1_op_f32_t)>(
    symbol: 'ggml_map_custom1_f32', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_map_custom1_f32(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ggml_custom1_op_f32_t fun,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ggml_custom1_op_t,
            ffi.Int,
            ffi.Pointer<ffi.Void>)>(
    symbol: 'ggml_map_custom1_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_map_custom1_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ggml_custom1_op_t fun,
  int n_tasks,
  ffi.Pointer<ffi.Void> userdata,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ggml_custom1_op_f32_t)>(
    symbol: 'ggml_map_custom1_inplace_f32', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_map_custom1_inplace_f32(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ggml_custom1_op_f32_t fun,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ggml_custom2_op_t,
            ffi.Int,
            ffi.Pointer<ffi.Void>)>(
    symbol: 'ggml_map_custom2', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_map_custom2(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  ggml_custom2_op_t fun,
  int n_tasks,
  ffi.Pointer<ffi.Void> userdata,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ggml_custom2_op_f32_t)>(
    symbol: 'ggml_map_custom2_f32', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_map_custom2_f32(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  ggml_custom2_op_f32_t fun,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ggml_custom2_op_t,
            ffi.Int,
            ffi.Pointer<ffi.Void>)>(
    symbol: 'ggml_map_custom2_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_map_custom2_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  ggml_custom2_op_t fun,
  int n_tasks,
  ffi.Pointer<ffi.Void> userdata,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ggml_custom2_op_f32_t)>(
    symbol: 'ggml_map_custom2_inplace_f32', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_map_custom2_inplace_f32(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  ggml_custom2_op_f32_t fun,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ggml_custom3_op_t,
            ffi.Int,
            ffi.Pointer<ffi.Void>)>(
    symbol: 'ggml_map_custom3', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_map_custom3(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  ffi.Pointer<ggml_tensor> c,
  ggml_custom3_op_t fun,
  int n_tasks,
  ffi.Pointer<ffi.Void> userdata,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ggml_custom3_op_f32_t)>(
    symbol: 'ggml_map_custom3_f32', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_map_custom3_f32(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  ffi.Pointer<ggml_tensor> c,
  ggml_custom3_op_f32_t fun,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ggml_custom3_op_t,
            ffi.Int,
            ffi.Pointer<ffi.Void>)>(
    symbol: 'ggml_map_custom3_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_map_custom3_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  ffi.Pointer<ggml_tensor> c,
  ggml_custom3_op_t fun,
  int n_tasks,
  ffi.Pointer<ffi.Void> userdata,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ggml_custom3_op_f32_t)>(
    symbol: 'ggml_map_custom3_inplace_f32', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_map_custom3_inplace_f32(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  ffi.Pointer<ggml_tensor> c,
  ggml_custom3_op_f32_t fun,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ggml_unary_op_f32_t)>(
    symbol: 'ggml_map_unary_f32', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_map_unary_f32(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ggml_unary_op_f32_t fun,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ggml_unary_op_f32_t)>(
    symbol: 'ggml_map_unary_inplace_f32', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_map_unary_inplace_f32(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ggml_unary_op_f32_t fun,
);

/// mean along rows
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_mean', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_mean(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_mul', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_mul(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_mul_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_mul_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

/// A: k columns, n rows => [ne03, ne02, n, k]
/// B: k columns, m rows  (i.e. we transpose it internally) => [ne03 * x, ne02 * y, m, k]
/// result is n columns, m rows => [ne03 * x, ne02 * y, m, n]
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_mul_mat', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_mul_mat(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

/// indirect matrix multiplication
/// ggml_mul_mat_id(ctx, as, ids, id, b) ~= ggml_mul_mat(as[ids[id]], b)
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Int,
            ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_mul_mat_id', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_mul_mat_id(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> as1,
  ffi.Pointer<ggml_tensor> ids,
  int id,
  ffi.Pointer<ggml_tensor> b,
);

/// change the precision of a matrix multiplication
/// set to GGML_PREC_F32 for higher precision (useful for phi-2)
@ffi.Native<ffi.Void Function(ffi.Pointer<ggml_tensor>, ffi.Int32)>(
    symbol: 'ggml_mul_mat_set_prec', assetId: 'package:ggml/ggml.dart')
external void ggml_mul_mat_set_prec(
  ffi.Pointer<ggml_tensor> a,
  int prec,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_n_dims', assetId: 'package:ggml/ggml.dart')
external int ggml_n_dims(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_nbytes', assetId: 'package:ggml/ggml.dart')
external int ggml_nbytes(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_nbytes_pad', assetId: 'package:ggml/ggml.dart')
external int ggml_nbytes_pad(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_neg', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_neg(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_neg_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_neg_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<ffi.Int64 Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_nelements', assetId: 'package:ggml/ggml.dart')
external int ggml_nelements(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
        ffi.Float)>(symbol: 'ggml_new_f32', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_new_f32(
  ffi.Pointer<ggml_context> ctx,
  double value,
);

/// graph allocation in a context
@ffi.Native<ffi.Pointer<ggml_cgraph> Function(ffi.Pointer<ggml_context>)>(
    symbol: 'ggml_new_graph', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_cgraph> ggml_new_graph(
  ffi.Pointer<ggml_context> ctx,
);

@ffi.Native<
        ffi.Pointer<ggml_cgraph> Function(
            ffi.Pointer<ggml_context>, ffi.Size, ffi.Bool)>(
    symbol: 'ggml_new_graph_custom', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_cgraph> ggml_new_graph_custom(
  ffi.Pointer<ggml_context> ctx,
  int size,
  bool grads,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
        ffi.Int32)>(symbol: 'ggml_new_i32', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_new_i32(
  ffi.Pointer<ggml_context> ctx,
  int value,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>, ffi.Int32,
            ffi.Int, ffi.Pointer<ffi.Int64>)>(
    symbol: 'ggml_new_tensor', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_new_tensor(
  ffi.Pointer<ggml_context> ctx,
  int type,
  int n_dims,
  ffi.Pointer<ffi.Int64> ne,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Int32, ffi.Int64)>(
    symbol: 'ggml_new_tensor_1d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_new_tensor_1d(
  ffi.Pointer<ggml_context> ctx,
  int type,
  int ne0,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Int32, ffi.Int64, ffi.Int64)>(
    symbol: 'ggml_new_tensor_2d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_new_tensor_2d(
  ffi.Pointer<ggml_context> ctx,
  int type,
  int ne0,
  int ne1,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>, ffi.Int32,
            ffi.Int64, ffi.Int64, ffi.Int64)>(
    symbol: 'ggml_new_tensor_3d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_new_tensor_3d(
  ffi.Pointer<ggml_context> ctx,
  int type,
  int ne0,
  int ne1,
  int ne2,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>, ffi.Int32,
            ffi.Int64, ffi.Int64, ffi.Int64, ffi.Int64)>(
    symbol: 'ggml_new_tensor_4d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_new_tensor_4d(
  ffi.Pointer<ggml_context> ctx,
  int type,
  int ne0,
  int ne1,
  int ne2,
  int ne3,
);

/// normalize along rows
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Float)>(symbol: 'ggml_norm', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_norm(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  double eps,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>, ffi.Float)>(
    symbol: 'ggml_norm_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_norm_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  double eps,
);

@ffi.Native<ffi.Int64 Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_nrows', assetId: 'package:ggml/ggml.dart')
external int ggml_nrows(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Void Function(ffi.Int32)>(
    symbol: 'ggml_numa_init', assetId: 'package:ggml/ggml.dart')
external void ggml_numa_init(
  int numa,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_op_desc', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Char> ggml_op_desc(
  ffi.Pointer<ggml_tensor> t,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Int32)>(
    symbol: 'ggml_op_name', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Char> ggml_op_name(
  int op,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Int32)>(
    symbol: 'ggml_op_symbol', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Char> ggml_op_symbol(
  int op,
);

/// optimize the function defined by the tensor f
@ffi.Native<
        ffi.Int32 Function(ffi.Pointer<ggml_context>, ggml_opt_params,
            ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_opt', assetId: 'package:ggml/ggml.dart')
external int ggml_opt(
  ffi.Pointer<ggml_context> ctx,
  ggml_opt_params params,
  ffi.Pointer<ggml_tensor> f,
);

@ffi.Native<ggml_opt_params Function(ffi.Int32)>(
    symbol: 'ggml_opt_default_params', assetId: 'package:ggml/ggml.dart')
external ggml_opt_params ggml_opt_default_params(
  int type,
);

/// initialize optimizer context
@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_opt_context>,
        ggml_opt_params,
        ffi.Int64)>(symbol: 'ggml_opt_init', assetId: 'package:ggml/ggml.dart')
external void ggml_opt_init(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_opt_context> opt,
  ggml_opt_params params,
  int nx,
);

/// continue optimizing the function defined by the tensor f
@ffi.Native<
        ffi.Int32 Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_opt_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_opt_resume', assetId: 'package:ggml/ggml.dart')
external int ggml_opt_resume(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_opt_context> opt,
  ffi.Pointer<ggml_tensor> f,
);

/// continue optimizing the function defined by the tensor f
@ffi.Native<
        ffi.Int32 Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_opt_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_cgraph>,
            ffi.Pointer<ggml_cgraph>,
            ggml_opt_callback,
            ffi.Pointer<ffi.Void>)>(
    symbol: 'ggml_opt_resume_g', assetId: 'package:ggml/ggml.dart')
external int ggml_opt_resume_g(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_opt_context> opt,
  ffi.Pointer<ggml_tensor> f,
  ffi.Pointer<ggml_cgraph> gf,
  ffi.Pointer<ggml_cgraph> gb,
  ggml_opt_callback callback,
  ffi.Pointer<ffi.Void> callback_data,
);

/// A: m columns, n rows,
/// B: p columns, n rows,
/// result is m columns, p rows
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_out_prod', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_out_prod(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

/// pad each dimension with zeros: [x, ..., x] -> [x, ..., x, 0, ..., 0]
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        ffi.Int)>(symbol: 'ggml_pad', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_pad(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int p0,
  int p1,
  int p2,
  int p3,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        ffi.Int)>(symbol: 'ggml_permute', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_permute(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int axis0,
  int axis1,
  int axis2,
  int axis3,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int32,
        ffi.Int,
        ffi.Int,
        ffi.Int)>(symbol: 'ggml_pool_1d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_pool_1d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int op,
  int k0,
  int s0,
  int p0,
);

/// the result will have 2*p0 padding for the first dimension
/// and 2*p1 padding for the second dimension
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int32,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        ffi.Float,
        ffi.Float)>(symbol: 'ggml_pool_2d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_pool_2d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int op,
  int k0,
  int k1,
  int s0,
  int s1,
  double p0,
  double p1,
);

@ffi.Native<ffi.Void Function()>(
    symbol: 'ggml_print_backtrace', assetId: 'package:ggml/ggml.dart')
external void ggml_print_backtrace();

@ffi.Native<ffi.Void Function(ffi.Pointer<ggml_object>)>(
    symbol: 'ggml_print_object', assetId: 'package:ggml/ggml.dart')
external void ggml_print_object(
  ffi.Pointer<ggml_object> obj,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ggml_context>)>(
    symbol: 'ggml_print_objects', assetId: 'package:ggml/ggml.dart')
external void ggml_print_objects(
  ffi.Pointer<ggml_context> ctx,
);

/// calls ggml_quantize_init internally (i.e. can allocate memory)
@ffi.Native<
        ffi.Size Function(
            ffi.Int32,
            ffi.Pointer<ffi.Float>,
            ffi.Pointer<ffi.Void>,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64,
            ffi.Pointer<ffi.Float>)>(
    symbol: 'ggml_quantize_chunk', assetId: 'package:ggml/ggml.dart')
external int ggml_quantize_chunk(
  int type,
  ffi.Pointer<ffi.Float> src,
  ffi.Pointer<ffi.Void> dst,
  int start,
  int nrows,
  int n_per_row,
  ffi.Pointer<ffi.Float> imatrix,
);

@ffi.Native<ffi.Void Function()>(
    symbol: 'ggml_quantize_free', assetId: 'package:ggml/ggml.dart')
external void ggml_quantize_free();

/// - ggml_quantize_init can be called multiple times with the same type
/// it will only initialize the quantization tables for the first call or after ggml_quantize_free
/// automatically called by ggml_quantize_chunk for convenience
///
/// - ggml_quantize_free will free any memory allocated by ggml_quantize_init
/// call this at the end of the program to avoid memory leaks
///
/// note: these are thread-safe
@ffi.Native<ffi.Void Function(ffi.Int32)>(
    symbol: 'ggml_quantize_init', assetId: 'package:ggml/ggml.dart')
external void ggml_quantize_init(
  int type,
);

/// some quantization type cannot be used without an importance matrix
@ffi.Native<ffi.Bool Function(ffi.Int32)>(
    symbol: 'ggml_quantize_requires_imatrix', assetId: 'package:ggml/ggml.dart')
external bool ggml_quantize_requires_imatrix(
  int type,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_relu', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_relu(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_relu_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_relu_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

/// if a is the same shape as b, and a is not parameter, return a
/// otherwise, return a new tensor: repeat(a) to fit in b
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_repeat', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_repeat(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

/// sums repetitions in a into shape of b
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_repeat_back', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_repeat_back(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

/// return view(a), b specifies the new shape
/// TODO: when we start computing gradient, make a copy instead of view
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_reshape', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_reshape(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

/// return view(a)
/// TODO: when we start computing gradient, make a copy instead of view
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>, ffi.Int64)>(
    symbol: 'ggml_reshape_1d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_reshape_1d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int ne0,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Int64, ffi.Int64)>(
    symbol: 'ggml_reshape_2d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_reshape_2d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int ne0,
  int ne1,
);

/// return view(a)
/// TODO: when we start computing gradient, make a copy instead of view
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Int64, ffi.Int64, ffi.Int64)>(
    symbol: 'ggml_reshape_3d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_reshape_3d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int ne0,
  int ne1,
  int ne2,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64)>(
    symbol: 'ggml_reshape_4d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_reshape_4d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int ne0,
  int ne1,
  int ne2,
  int ne3,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Float)>(symbol: 'ggml_rms_norm', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_rms_norm(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  double eps,
);

/// a - x
/// b - dy
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>, ffi.Float)>(
    symbol: 'ggml_rms_norm_back', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_rms_norm_back(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  double eps,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>, ffi.Float)>(
    symbol: 'ggml_rms_norm_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_rms_norm_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  double eps,
);

/// rotary position embedding
/// if mode & 1 == 1, skip n_past elements (DEPRECATED)
/// if mode & 2 == 1, GPT-NeoX style
/// if mode & 4 == 1, ChatGLM style
///
/// b is an int32 vector with size a->ne[2], it contains the positions
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int,
        ffi.Int,
        ffi.Int)>(symbol: 'ggml_rope', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_rope(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int n_dims,
  int mode,
  int n_ctx,
);

/// rotary position embedding backward, i.e compute dx from dy
/// a - dy
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Float,
        ffi.Bool)>(symbol: 'ggml_rope_back', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_rope_back(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int n_dims,
  int mode,
  int n_ctx,
  int n_orig_ctx,
  double freq_base,
  double freq_scale,
  double ext_factor,
  double attn_factor,
  double beta_fast,
  double beta_slow,
  double xpos_base,
  bool xpos_down,
);

/// custom RoPE
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float)>(
    symbol: 'ggml_rope_custom', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_rope_custom(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int n_dims,
  int mode,
  int n_ctx,
  int n_orig_ctx,
  double freq_base,
  double freq_scale,
  double ext_factor,
  double attn_factor,
  double beta_fast,
  double beta_slow,
);

/// in-place, returns view(a)
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Int,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float)>(
    symbol: 'ggml_rope_custom_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_rope_custom_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int n_dims,
  int mode,
  int n_ctx,
  int n_orig_ctx,
  double freq_base,
  double freq_scale,
  double ext_factor,
  double attn_factor,
  double beta_fast,
  double beta_slow,
);

/// in-place, returns view(a)
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Int,
            ffi.Int,
            ffi.Int)>(
    symbol: 'ggml_rope_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_rope_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int n_dims,
  int mode,
  int n_ctx,
);

/// xPos RoPE, in-place, returns view(a)
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Int,
            ffi.Float,
            ffi.Bool)>(
    symbol: 'ggml_rope_xpos_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_rope_xpos_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int n_dims,
  double base,
  bool down,
);

/// compute correction dims for YaRN RoPE scaling
@ffi.Native<
        ffi.Void Function(ffi.Int, ffi.Int, ffi.Float, ffi.Float, ffi.Float,
            ffi.Pointer<ffi.Float>)>(
    symbol: 'ggml_rope_yarn_corr_dims', assetId: 'package:ggml/ggml.dart')
external void ggml_rope_yarn_corr_dims(
  int n_dims,
  int n_orig_ctx,
  double freq_base,
  double beta_fast,
  double beta_slow,
  ffi.Pointer<ffi.Float> dims,
);

@ffi.Native<ffi.Size Function(ffi.Int32, ffi.Int64)>(
    symbol: 'ggml_row_size', assetId: 'package:ggml/ggml.dart')
external int ggml_row_size(
  int type,
  int ne,
);

/// operations on tensors without backpropagation
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Float)>(symbol: 'ggml_scale', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_scale(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  double s,
);

/// in-place, returns view(a)
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>, ffi.Float)>(
    symbol: 'ggml_scale_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_scale_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  double s,
);

/// b -> view(a,offset,nb1,nb2,3), return modified a
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Pointer<ggml_tensor>,
        ffi.Size,
        ffi.Size,
        ffi.Size,
        ffi.Size)>(symbol: 'ggml_set', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_set(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int nb1,
  int nb2,
  int nb3,
  int offset,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Pointer<ggml_tensor>,
        ffi.Size)>(symbol: 'ggml_set_1d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_set_1d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int offset,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>, ffi.Size)>(
    symbol: 'ggml_set_1d_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_set_1d_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int offset,
);

/// b -> view(a,offset,nb1,nb2,3), return modified a
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Pointer<ggml_tensor>,
        ffi.Size,
        ffi.Size)>(symbol: 'ggml_set_2d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_set_2d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int nb1,
  int offset,
);

/// b -> view(a,offset,nb1,nb2,3), return view(a)
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Size,
            ffi.Size)>(
    symbol: 'ggml_set_2d_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_set_2d_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int nb1,
  int offset,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_tensor>, ffi.Float)>(
    symbol: 'ggml_set_f32', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_set_f32(
  ffi.Pointer<ggml_tensor> tensor,
  double value,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ggml_tensor>, ffi.Int, ffi.Float)>(
    symbol: 'ggml_set_f32_1d', assetId: 'package:ggml/ggml.dart')
external void ggml_set_f32_1d(
  ffi.Pointer<ggml_tensor> tensor,
  int i,
  double value,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<ggml_tensor>, ffi.Int, ffi.Int, ffi.Int,
            ffi.Int, ffi.Float)>(
    symbol: 'ggml_set_f32_nd', assetId: 'package:ggml/ggml.dart')
external void ggml_set_f32_nd(
  ffi.Pointer<ggml_tensor> tensor,
  int i0,
  int i1,
  int i2,
  int i3,
  double value,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_tensor>, ffi.Int32)>(
    symbol: 'ggml_set_i32', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_set_i32(
  ffi.Pointer<ggml_tensor> tensor,
  int value,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ggml_tensor>, ffi.Int, ffi.Int32)>(
    symbol: 'ggml_set_i32_1d', assetId: 'package:ggml/ggml.dart')
external void ggml_set_i32_1d(
  ffi.Pointer<ggml_tensor> tensor,
  int i,
  int value,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<ggml_tensor>, ffi.Int, ffi.Int, ffi.Int,
            ffi.Int, ffi.Int32)>(
    symbol: 'ggml_set_i32_nd', assetId: 'package:ggml/ggml.dart')
external void ggml_set_i32_nd(
  ffi.Pointer<ggml_tensor> tensor,
  int i0,
  int i1,
  int i2,
  int i3,
  int value,
);

/// b -> view(a,offset,nb1,nb2,3), return view(a)
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Size,
            ffi.Size,
            ffi.Size,
            ffi.Size)>(
    symbol: 'ggml_set_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_set_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
  int nb1,
  int nb2,
  int nb3,
  int offset,
);

/// tensor flags
@ffi.Native<ffi.Void Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_set_input', assetId: 'package:ggml/ggml.dart')
external void ggml_set_input(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ffi.Char>)>(
    symbol: 'ggml_set_name', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_set_name(
  ffi.Pointer<ggml_tensor> tensor,
  ffi.Pointer<ffi.Char> name,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ggml_context>, ffi.Bool)>(
    symbol: 'ggml_set_no_alloc', assetId: 'package:ggml/ggml.dart')
external void ggml_set_no_alloc(
  ffi.Pointer<ggml_context> ctx,
  bool no_alloc,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_set_output', assetId: 'package:ggml/ggml.dart')
external void ggml_set_output(
  ffi.Pointer<ggml_tensor> tensor,
);

/// automatic differentiation
@ffi.Native<
        ffi.Void Function(ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_set_param', assetId: 'package:ggml/ggml.dart')
external void ggml_set_param(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<ggml_context>, ggml_scratch)>(
    symbol: 'ggml_set_scratch', assetId: 'package:ggml/ggml.dart')
external int ggml_set_scratch(
  ffi.Pointer<ggml_context> ctx,
  ggml_scratch scratch,
);

@ffi.Native<ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_set_zero', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_set_zero(
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_sgn', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_sgn(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_sgn_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_sgn_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_silu', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_silu(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

/// a - x
/// b - dy
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_silu_back', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_silu_back(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_silu_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_silu_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_soft_max', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_soft_max(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_soft_max_back', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_soft_max_back(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

/// in-place, returns view(a)
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_soft_max_back_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_soft_max_back_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

/// fused soft_max(a*scale + mask + pos[i]*(ALiBi slope))
/// mask is optional
/// pos is required when max_bias > 0.0f
/// max_bias = 0.0f for no ALiBi
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Float,
            ffi.Float)>(
    symbol: 'ggml_soft_max_ext', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_soft_max_ext(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> mask,
  ffi.Pointer<ggml_tensor> pos,
  double scale,
  double max_bias,
);

/// in-place, returns view(a)
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_soft_max_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_soft_max_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_sqr', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_sqr(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_sqr_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_sqr_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_sqrt', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_sqrt(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_sqrt_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_sqrt_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_ssm_conv', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_ssm_conv(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> s,
  ffi.Pointer<ggml_tensor> x,
  ffi.Pointer<ggml_tensor> c,
  ffi.Pointer<ggml_tensor> sq,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>,
            ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_ssm_scan', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_ssm_scan(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> s,
  ffi.Pointer<ggml_tensor> x,
  ffi.Pointer<ggml_tensor> dt,
  ffi.Pointer<ggml_tensor> A,
  ffi.Pointer<ggml_tensor> B,
  ffi.Pointer<ggml_tensor> C,
  ffi.Pointer<ggml_tensor> sq,
);

/// get ggml_status name string
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Int32)>(
    symbol: 'ggml_status_to_string', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Char> ggml_status_to_string(
  int status,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_step', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_step(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_step_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_step_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_sub', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_sub(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_sub_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_sub_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  ffi.Pointer<ggml_tensor> b,
);

/// return scalar
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_sum', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_sum(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

/// sums along rows, with input shape [a,b,c,d] return shape [1,b,c,d]
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_sum_rows', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_sum_rows(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<ggml_tallocr>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_tallocr_alloc', assetId: 'package:ggml/ggml.dart')
external void ggml_tallocr_alloc(
  ffi.Pointer<ggml_tallocr> talloc,
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ggml_tallocr Function(ggml_backend_buffer_t)>(
    symbol: 'ggml_tallocr_new', assetId: 'package:ggml/ggml.dart')
external ggml_tallocr ggml_tallocr_new(
  ggml_backend_buffer_t buffer,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_tanh', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_tanh(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_tanh_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_tanh_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

/// use this to compute the memory overhead of a tensor
@ffi.Native<ffi.Size Function()>(
    symbol: 'ggml_tensor_overhead', assetId: 'package:ggml/ggml.dart')
external int ggml_tensor_overhead();

/// misc
@ffi.Native<ffi.Void Function()>(
    symbol: 'ggml_time_init', assetId: 'package:ggml/ggml.dart')
external void ggml_time_init();

@ffi.Native<ffi.Int64 Function()>(
    symbol: 'ggml_time_ms', assetId: 'package:ggml/ggml.dart')
external int ggml_time_ms();

@ffi.Native<ffi.Int64 Function()>(
    symbol: 'ggml_time_us', assetId: 'package:ggml/ggml.dart')
external int ggml_time_us();

/// Ref: https://github.com/CompVis/stable-diffusion/blob/main/ldm/modules/diffusionmodules/util.py#L151
/// timesteps: [N,]
/// return: [N, dim]
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(ffi.Pointer<ggml_context>,
            ffi.Pointer<ggml_tensor>, ffi.Int, ffi.Int)>(
    symbol: 'ggml_timestep_embedding', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_timestep_embedding(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> timesteps,
  int dim,
  int max_period,
);

/// top k elements per row
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int)>(symbol: 'ggml_top_k', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_top_k(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int k,
);

/// alias for ggml_permute(ctx, a, 1, 0, 2, 3)
@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_transpose', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_transpose(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Int32)>(
    symbol: 'ggml_type_name', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Char> ggml_type_name(
  int type,
);

@ffi.Native<ffi.Size Function(ffi.Int32)>(
    symbol: 'ggml_type_size', assetId: 'package:ggml/ggml.dart')
external int ggml_type_size(
  int type,
);

@ffi.Native<ffi.Double Function(ffi.Int32)>(
    symbol: 'ggml_type_sizef', assetId: 'package:ggml/ggml.dart')
external double ggml_type_sizef(
  int type,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int32)>(symbol: 'ggml_unary', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_unary(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int op,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>, ffi.Int32)>(
    symbol: 'ggml_unary_inplace', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_unary_inplace(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int op,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Int32)>(
    symbol: 'ggml_unary_op_name', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Char> ggml_unary_op_name(
  int op,
);

/// Converts a flat index into coordinates
@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<ggml_tensor>,
            ffi.Int64,
            ffi.Pointer<ffi.Int64>,
            ffi.Pointer<ffi.Int64>,
            ffi.Pointer<ffi.Int64>,
            ffi.Pointer<ffi.Int64>)>(
    symbol: 'ggml_unravel_index', assetId: 'package:ggml/ggml.dart')
external void ggml_unravel_index(
  ffi.Pointer<ggml_tensor> tensor,
  int i,
  ffi.Pointer<ffi.Int64> i0,
  ffi.Pointer<ffi.Int64> i1,
  ffi.Pointer<ffi.Int64> i2,
  ffi.Pointer<ffi.Int64> i3,
);

/// nearest interpolate
/// used in stable-diffusion
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int)>(symbol: 'ggml_upscale', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_upscale(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int scale_factor,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<ggml_context>)>(
    symbol: 'ggml_used_mem', assetId: 'package:ggml/ggml.dart')
external int ggml_used_mem(
  ffi.Pointer<ggml_context> ctx,
);

/// offset in bytes
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int64,
        ffi.Size)>(symbol: 'ggml_view_1d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_view_1d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int ne0,
  int offset,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int64,
        ffi.Int64,
        ffi.Size,
        ffi.Size)>(symbol: 'ggml_view_2d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_view_2d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int ne0,
  int ne1,
  int nb1,
  int offset,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int64,
        ffi.Int64,
        ffi.Int64,
        ffi.Size,
        ffi.Size,
        ffi.Size)>(symbol: 'ggml_view_3d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_view_3d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int ne0,
  int ne1,
  int ne2,
  int nb1,
  int nb2,
  int offset,
);

@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int64,
        ffi.Int64,
        ffi.Int64,
        ffi.Int64,
        ffi.Size,
        ffi.Size,
        ffi.Size,
        ffi.Size)>(symbol: 'ggml_view_4d', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_view_4d(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int ne0,
  int ne1,
  int ne2,
  int ne3,
  int nb1,
  int nb2,
  int nb3,
  int offset,
);

@ffi.Native<
        ffi.Pointer<ggml_tensor> Function(
            ffi.Pointer<ggml_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'ggml_view_tensor', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_view_tensor(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> src,
);

/// partition into non-overlapping windows with padding if needed
/// example:
/// a:   768   64   64    1
/// w:    14
/// res: 768   14   14    25
/// used in sam
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int)>(symbol: 'ggml_win_part', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_win_part(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int w,
);

/// reverse of ggml_win_part
/// used in sam
@ffi.Native<
    ffi.Pointer<ggml_tensor> Function(
        ffi.Pointer<ggml_context>,
        ffi.Pointer<ggml_tensor>,
        ffi.Int,
        ffi.Int,
        ffi.Int)>(symbol: 'ggml_win_unpart', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ggml_tensor> ggml_win_unpart(
  ffi.Pointer<ggml_context> ctx,
  ffi.Pointer<ggml_tensor> a,
  int w0,
  int h0,
  int w,
);

/// manage tensor info
@ffi.Native<
        ffi.Void Function(ffi.Pointer<gguf_context>, ffi.Pointer<ggml_tensor>)>(
    symbol: 'gguf_add_tensor', assetId: 'package:ggml/ggml.dart')
external void gguf_add_tensor(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ggml_tensor> tensor,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Char>)>(
    symbol: 'gguf_find_key', assetId: 'package:ggml/ggml.dart')
external int gguf_find_key(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> key,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Char>)>(
    symbol: 'gguf_find_tensor', assetId: 'package:ggml/ggml.dart')
external int gguf_find_tensor(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> name,
);

/// GGML_API struct gguf_context * gguf_init_from_buffer(..);
@ffi.Native<ffi.Void Function(ffi.Pointer<gguf_context>)>(
    symbol: 'gguf_free', assetId: 'package:ggml/ggml.dart')
external void gguf_free(
  ffi.Pointer<gguf_context> ctx,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<gguf_context>)>(
    symbol: 'gguf_get_alignment', assetId: 'package:ggml/ggml.dart')
external int gguf_get_alignment(
  ffi.Pointer<gguf_context> ctx,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_arr_data', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Void> gguf_get_arr_data(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_arr_n', assetId: 'package:ggml/ggml.dart')
external int gguf_get_arr_n(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
);

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(ffi.Pointer<gguf_context>, ffi.Int,
        ffi.Int)>(symbol: 'gguf_get_arr_str', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Char> gguf_get_arr_str(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
  int i,
);

@ffi.Native<ffi.Int32 Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_arr_type', assetId: 'package:ggml/ggml.dart')
external int gguf_get_arr_type(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Pointer<gguf_context>)>(
    symbol: 'gguf_get_data', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Void> gguf_get_data(
  ffi.Pointer<gguf_context> ctx,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<gguf_context>)>(
    symbol: 'gguf_get_data_offset', assetId: 'package:ggml/ggml.dart')
external int gguf_get_data_offset(
  ffi.Pointer<gguf_context> ctx,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_key', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Char> gguf_get_key(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
);

@ffi.Native<ffi.Int32 Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_kv_type', assetId: 'package:ggml/ggml.dart')
external int gguf_get_kv_type(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Void>)>(
    symbol: 'gguf_get_meta_data', assetId: 'package:ggml/ggml.dart')
external void gguf_get_meta_data(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Void> data,
);

/// get the size in bytes of the meta data (header, kv pairs, tensor info) including padding
@ffi.Native<ffi.Size Function(ffi.Pointer<gguf_context>)>(
    symbol: 'gguf_get_meta_size', assetId: 'package:ggml/ggml.dart')
external int gguf_get_meta_size(
  ffi.Pointer<gguf_context> ctx,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<gguf_context>)>(
    symbol: 'gguf_get_n_kv', assetId: 'package:ggml/ggml.dart')
external int gguf_get_n_kv(
  ffi.Pointer<gguf_context> ctx,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<gguf_context>)>(
    symbol: 'gguf_get_n_tensors', assetId: 'package:ggml/ggml.dart')
external int gguf_get_n_tensors(
  ffi.Pointer<gguf_context> ctx,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_tensor_name', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Char> gguf_get_tensor_name(
  ffi.Pointer<gguf_context> ctx,
  int i,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_tensor_offset', assetId: 'package:ggml/ggml.dart')
external int gguf_get_tensor_offset(
  ffi.Pointer<gguf_context> ctx,
  int i,
);

@ffi.Native<ffi.Int32 Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_tensor_type', assetId: 'package:ggml/ggml.dart')
external int gguf_get_tensor_type(
  ffi.Pointer<gguf_context> ctx,
  int i,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_val_bool', assetId: 'package:ggml/ggml.dart')
external bool gguf_get_val_bool(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_val_data', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Void> gguf_get_val_data(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
);

@ffi.Native<ffi.Float Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_val_f32', assetId: 'package:ggml/ggml.dart')
external double gguf_get_val_f32(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
);

@ffi.Native<ffi.Double Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_val_f64', assetId: 'package:ggml/ggml.dart')
external double gguf_get_val_f64(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
);

@ffi.Native<ffi.Int16 Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_val_i16', assetId: 'package:ggml/ggml.dart')
external int gguf_get_val_i16(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
);

@ffi.Native<ffi.Int32 Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_val_i32', assetId: 'package:ggml/ggml.dart')
external int gguf_get_val_i32(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
);

@ffi.Native<ffi.Int64 Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_val_i64', assetId: 'package:ggml/ggml.dart')
external int gguf_get_val_i64(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
);

@ffi.Native<ffi.Int8 Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_val_i8', assetId: 'package:ggml/ggml.dart')
external int gguf_get_val_i8(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_val_str', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Char> gguf_get_val_str(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
);

@ffi.Native<ffi.Uint16 Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_val_u16', assetId: 'package:ggml/ggml.dart')
external int gguf_get_val_u16(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
);

@ffi.Native<ffi.Uint32 Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_val_u32', assetId: 'package:ggml/ggml.dart')
external int gguf_get_val_u32(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
);

@ffi.Native<ffi.Uint64 Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_val_u64', assetId: 'package:ggml/ggml.dart')
external int gguf_get_val_u64(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
);

/// will abort if the wrong type is used for the key
@ffi.Native<ffi.Uint8 Function(ffi.Pointer<gguf_context>, ffi.Int)>(
    symbol: 'gguf_get_val_u8', assetId: 'package:ggml/ggml.dart')
external int gguf_get_val_u8(
  ffi.Pointer<gguf_context> ctx,
  int key_id,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<gguf_context>)>(
    symbol: 'gguf_get_version', assetId: 'package:ggml/ggml.dart')
external int gguf_get_version(
  ffi.Pointer<gguf_context> ctx,
);

@ffi.Native<ffi.Pointer<gguf_context> Function()>(
    symbol: 'gguf_init_empty', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<gguf_context> gguf_init_empty();

@ffi.Native<
        ffi.Pointer<gguf_context> Function(
            ffi.Pointer<ffi.Char>, gguf_init_params)>(
    symbol: 'gguf_init_from_file', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<gguf_context> gguf_init_from_file(
  ffi.Pointer<ffi.Char> fname,
  gguf_init_params params,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Char>,
            ffi.Int32, ffi.Pointer<ffi.Void>, ffi.Int)>(
    symbol: 'gguf_set_arr_data', assetId: 'package:ggml/ggml.dart')
external void gguf_set_arr_data(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> key,
  int type,
  ffi.Pointer<ffi.Void> data,
  int n,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<gguf_context>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Pointer<ffi.Char>>,
        ffi.Int)>(symbol: 'gguf_set_arr_str', assetId: 'package:ggml/ggml.dart')
external void gguf_set_arr_str(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> key,
  ffi.Pointer<ffi.Pointer<ffi.Char>> data,
  int n,
);

/// set or add KV pairs from another context
@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<gguf_context>, ffi.Pointer<gguf_context>)>(
    symbol: 'gguf_set_kv', assetId: 'package:ggml/ggml.dart')
external void gguf_set_kv(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<gguf_context> src,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Void>, ffi.Size)>(
    symbol: 'gguf_set_tensor_data', assetId: 'package:ggml/ggml.dart')
external void gguf_set_tensor_data(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> name,
  ffi.Pointer<ffi.Void> data,
  int size,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Char>, ffi.Int32)>(
    symbol: 'gguf_set_tensor_type', assetId: 'package:ggml/ggml.dart')
external void gguf_set_tensor_type(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> name,
  int type,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Char>, ffi.Bool)>(
    symbol: 'gguf_set_val_bool', assetId: 'package:ggml/ggml.dart')
external void gguf_set_val_bool(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> key,
  bool val,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Char>, ffi.Float)>(
    symbol: 'gguf_set_val_f32', assetId: 'package:ggml/ggml.dart')
external void gguf_set_val_f32(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> key,
  double val,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Char>, ffi.Double)>(
    symbol: 'gguf_set_val_f64', assetId: 'package:ggml/ggml.dart')
external void gguf_set_val_f64(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> key,
  double val,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Char>, ffi.Int16)>(
    symbol: 'gguf_set_val_i16', assetId: 'package:ggml/ggml.dart')
external void gguf_set_val_i16(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> key,
  int val,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Char>, ffi.Int32)>(
    symbol: 'gguf_set_val_i32', assetId: 'package:ggml/ggml.dart')
external void gguf_set_val_i32(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> key,
  int val,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Char>, ffi.Int64)>(
    symbol: 'gguf_set_val_i64', assetId: 'package:ggml/ggml.dart')
external void gguf_set_val_i64(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> key,
  int val,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Char>,
        ffi.Int8)>(symbol: 'gguf_set_val_i8', assetId: 'package:ggml/ggml.dart')
external void gguf_set_val_i8(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> key,
  int val,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>)>(
    symbol: 'gguf_set_val_str', assetId: 'package:ggml/ggml.dart')
external void gguf_set_val_str(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> key,
  ffi.Pointer<ffi.Char> val,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Char>, ffi.Uint16)>(
    symbol: 'gguf_set_val_u16', assetId: 'package:ggml/ggml.dart')
external void gguf_set_val_u16(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> key,
  int val,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Char>, ffi.Uint32)>(
    symbol: 'gguf_set_val_u32', assetId: 'package:ggml/ggml.dart')
external void gguf_set_val_u32(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> key,
  int val,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Char>, ffi.Uint64)>(
    symbol: 'gguf_set_val_u64', assetId: 'package:ggml/ggml.dart')
external void gguf_set_val_u64(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> key,
  int val,
);

/// overrides existing values or adds a new one
@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Char>, ffi.Uint8)>(
    symbol: 'gguf_set_val_u8', assetId: 'package:ggml/ggml.dart')
external void gguf_set_val_u8(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> key,
  int val,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Int32)>(
    symbol: 'gguf_type_name', assetId: 'package:ggml/ggml.dart')
external ffi.Pointer<ffi.Char> gguf_type_name(
  int type,
);

/// write the entire context to a binary file
@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<gguf_context>, ffi.Pointer<ffi.Char>, ffi.Bool)>(
    symbol: 'gguf_write_to_file', assetId: 'package:ggml/ggml.dart')
external void gguf_write_to_file(
  ffi.Pointer<gguf_context> ctx,
  ffi.Pointer<ffi.Char> fname,
  bool only_meta,
);

typedef FILE = _iobuf;

const int GGML_DEFAULT_GRAPH_SIZE = 2048;

const int GGML_DEFAULT_N_THREADS = 4;

const int GGML_EXIT_ABORTED = 1;

const int GGML_EXIT_SUCCESS = 0;

const int GGML_FILE_MAGIC = 1734831468;

const int GGML_FILE_VERSION = 1;

const int GGML_MAX_CONTEXTS = 64;

const int GGML_MAX_DIMS = 4;

const int GGML_MAX_NAME = 64;

const int GGML_MAX_OP_PARAMS = 64;

const int GGML_MAX_PARAMS = 2048;

const int GGML_MAX_SRC = 10;

const int GGML_MEM_ALIGN = 16;

const int GGML_N_TASKS_MAX = -1;

const int GGML_QNT_VERSION = 2;

const int GGML_QNT_VERSION_FACTOR = 1000;

const int GGUF_DEFAULT_ALIGNMENT = 32;

const String GGUF_MAGIC = 'GGUF';

const int GGUF_VERSION = 3;

/// buffer
abstract class GgmlBackendBufferUsage {
  static const int GGML_BACKEND_BUFFER_USAGE_ANY = 0;
  static const int GGML_BACKEND_BUFFER_USAGE_WEIGHTS = 1;
}

abstract class GgmlBackendType {
  static const int GGML_BACKEND_TYPE_CPU = 0;
  static const int GGML_BACKEND_TYPE_GPU = 10;
  static const int GGML_BACKEND_TYPE_GPU_SPLIT = 20;
}

abstract class GgmlCGraphEvalOrder {
  static const int GGML_CGRAPH_EVAL_ORDER_LEFT_TO_RIGHT = 0;
  static const int GGML_CGRAPH_EVAL_ORDER_RIGHT_TO_LEFT = 1;
  static const int GGML_CGRAPH_EVAL_ORDER_COUNT = 2;
}

/// model file types
abstract class GgmlFtype {
  static const int GGML_FTYPE_UNKNOWN = -1;
  static const int GGML_FTYPE_ALL_F32 = 0;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_F16 = 1;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_Q4_0 = 2;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_Q4_1 = 3;

  /// tok_embeddings.weight and output.weight are F16
  static const int GGML_FTYPE_MOSTLY_Q4_1_SOME_F16 = 4;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_Q8_0 = 7;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_Q5_0 = 8;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_Q5_1 = 9;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_Q2_K = 10;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_Q3_K = 11;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_Q4_K = 12;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_Q5_K = 13;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_Q6_K = 14;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_IQ2_XXS = 15;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_IQ2_XS = 16;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_IQ3_XXS = 17;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_IQ1_S = 18;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_IQ4_NL = 19;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_IQ3_S = 20;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_IQ2_S = 21;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_IQ4_XS = 22;

  /// except 1d tensors
  static const int GGML_FTYPE_MOSTLY_IQ1_M = 23;
}

/// linesearch methods
abstract class GgmlLinesearch {
  static const int GGML_LINESEARCH_DEFAULT = 1;
  static const int GGML_LINESEARCH_BACKTRACKING_ARMIJO = 0;
  static const int GGML_LINESEARCH_BACKTRACKING_WOLFE = 1;
  static const int GGML_LINESEARCH_BACKTRACKING_STRONG_WOLFE = 2;
}

abstract class GgmlLogLevel {
  static const int GGML_LOG_LEVEL_ERROR = 2;
  static const int GGML_LOG_LEVEL_WARN = 3;
  static const int GGML_LOG_LEVEL_INFO = 4;
  static const int GGML_LOG_LEVEL_DEBUG = 5;
}

/// numa strategies
abstract class GgmlNumaStrategy {
  static const int GGML_NUMA_STRATEGY_DISABLED = 0;
  static const int GGML_NUMA_STRATEGY_DISTRIBUTE = 1;
  static const int GGML_NUMA_STRATEGY_ISOLATE = 2;
  static const int GGML_NUMA_STRATEGY_NUMACTL = 3;
  static const int GGML_NUMA_STRATEGY_MIRROR = 4;
  static const int GGML_NUMA_STRATEGY_COUNT = 5;
}

abstract class GgmlObjectType {
  static const int GGML_OBJECT_TYPE_TENSOR = 0;
  static const int GGML_OBJECT_TYPE_GRAPH = 1;
  static const int GGML_OBJECT_TYPE_WORK_BUFFER = 2;
}

/// available tensor operations:
abstract class GgmlOp {
  static const int GGML_OP_NONE = 0;
  static const int GGML_OP_DUP = 1;
  static const int GGML_OP_ADD = 2;
  static const int GGML_OP_ADD1 = 3;
  static const int GGML_OP_ACC = 4;
  static const int GGML_OP_SUB = 5;
  static const int GGML_OP_MUL = 6;
  static const int GGML_OP_DIV = 7;
  static const int GGML_OP_SQR = 8;
  static const int GGML_OP_SQRT = 9;
  static const int GGML_OP_LOG = 10;
  static const int GGML_OP_SUM = 11;
  static const int GGML_OP_SUM_ROWS = 12;
  static const int GGML_OP_MEAN = 13;
  static const int GGML_OP_ARGMAX = 14;
  static const int GGML_OP_REPEAT = 15;
  static const int GGML_OP_REPEAT_BACK = 16;
  static const int GGML_OP_CONCAT = 17;
  static const int GGML_OP_SILU_BACK = 18;

  /// normalize
  static const int GGML_OP_NORM = 19;
  static const int GGML_OP_RMS_NORM = 20;
  static const int GGML_OP_RMS_NORM_BACK = 21;
  static const int GGML_OP_GROUP_NORM = 22;
  static const int GGML_OP_MUL_MAT = 23;
  static const int GGML_OP_MUL_MAT_ID = 24;
  static const int GGML_OP_OUT_PROD = 25;
  static const int GGML_OP_SCALE = 26;
  static const int GGML_OP_SET = 27;
  static const int GGML_OP_CPY = 28;
  static const int GGML_OP_CONT = 29;
  static const int GGML_OP_RESHAPE = 30;
  static const int GGML_OP_VIEW = 31;
  static const int GGML_OP_PERMUTE = 32;
  static const int GGML_OP_TRANSPOSE = 33;
  static const int GGML_OP_GET_ROWS = 34;
  static const int GGML_OP_GET_ROWS_BACK = 35;
  static const int GGML_OP_DIAG = 36;
  static const int GGML_OP_DIAG_MASK_INF = 37;
  static const int GGML_OP_DIAG_MASK_ZERO = 38;
  static const int GGML_OP_SOFT_MAX = 39;
  static const int GGML_OP_SOFT_MAX_BACK = 40;
  static const int GGML_OP_ROPE = 41;
  static const int GGML_OP_ROPE_BACK = 42;
  static const int GGML_OP_ALIBI = 43;
  static const int GGML_OP_CLAMP = 44;
  static const int GGML_OP_CONV_TRANSPOSE_1D = 45;
  static const int GGML_OP_IM2COL = 46;
  static const int GGML_OP_CONV_TRANSPOSE_2D = 47;
  static const int GGML_OP_POOL_1D = 48;
  static const int GGML_OP_POOL_2D = 49;

  /// nearest interpolate
  static const int GGML_OP_UPSCALE = 50;
  static const int GGML_OP_PAD = 51;
  static const int GGML_OP_ARANGE = 52;
  static const int GGML_OP_TIMESTEP_EMBEDDING = 53;
  static const int GGML_OP_ARGSORT = 54;
  static const int GGML_OP_LEAKY_RELU = 55;
  static const int GGML_OP_FLASH_ATTN = 56;
  static const int GGML_OP_FLASH_FF = 57;
  static const int GGML_OP_FLASH_ATTN_BACK = 58;
  static const int GGML_OP_SSM_CONV = 59;
  static const int GGML_OP_SSM_SCAN = 60;
  static const int GGML_OP_WIN_PART = 61;
  static const int GGML_OP_WIN_UNPART = 62;
  static const int GGML_OP_GET_REL_POS = 63;
  static const int GGML_OP_ADD_REL_POS = 64;
  static const int GGML_OP_UNARY = 65;
  static const int GGML_OP_MAP_UNARY = 66;
  static const int GGML_OP_MAP_BINARY = 67;
  static const int GGML_OP_MAP_CUSTOM1_F32 = 68;
  static const int GGML_OP_MAP_CUSTOM2_F32 = 69;
  static const int GGML_OP_MAP_CUSTOM3_F32 = 70;
  static const int GGML_OP_MAP_CUSTOM1 = 71;
  static const int GGML_OP_MAP_CUSTOM2 = 72;
  static const int GGML_OP_MAP_CUSTOM3 = 73;
  static const int GGML_OP_CROSS_ENTROPY_LOSS = 74;
  static const int GGML_OP_CROSS_ENTROPY_LOSS_BACK = 75;
  static const int GGML_OP_COUNT = 76;
}

abstract class GgmlOpPool {
  static const int GGML_OP_POOL_MAX = 0;
  static const int GGML_OP_POOL_AVG = 1;
  static const int GGML_OP_POOL_COUNT = 2;
}

/// optimization return values
abstract class GgmlOptResult {
  static const int GGML_OPT_RESULT_OK = 0;
  static const int GGML_OPT_RESULT_DID_NOT_CONVERGE = 1;
  static const int GGML_OPT_RESULT_NO_CONTEXT = 2;
  static const int GGML_OPT_RESULT_INVALID_WOLFE = 3;
  static const int GGML_OPT_RESULT_FAIL = 4;
  static const int GGML_OPT_RESULT_CANCEL = 5;
  static const int GGML_LINESEARCH_FAIL = -128;
  static const int GGML_LINESEARCH_MINIMUM_STEP = -127;
  static const int GGML_LINESEARCH_MAXIMUM_STEP = -126;
  static const int GGML_LINESEARCH_MAXIMUM_ITERATIONS = -125;
  static const int GGML_LINESEARCH_INVALID_PARAMETERS = -124;
}

/// optimization methods
abstract class GgmlOptType {
  static const int GGML_OPT_TYPE_ADAM = 0;
  static const int GGML_OPT_TYPE_LBFGS = 1;
}

/// precision
abstract class GgmlPrec {
  static const int GGML_PREC_DEFAULT = 0;
  static const int GGML_PREC_F32 = 1;
}

/// sort rows
abstract class GgmlSortOrder {
  static const int GGML_SORT_ORDER_ASC = 0;
  static const int GGML_SORT_ORDER_DESC = 1;
}

abstract class GgmlStatus {
  static const int GGML_STATUS_ALLOC_FAILED = -2;
  static const int GGML_STATUS_FAILED = -1;
  static const int GGML_STATUS_SUCCESS = 0;
  static const int GGML_STATUS_ABORTED = 1;
}

/// NOTE: the INIT or FINALIZE pass is not scheduled unless explicitly enabled.
/// This behavior was changed since https://github.com/ggerganov/llama.cpp/pull/1995.
abstract class GgmlTaskType {
  static const int GGML_TASK_TYPE_INIT = 0;
  static const int GGML_TASK_TYPE_COMPUTE = 1;
  static const int GGML_TASK_TYPE_FINALIZE = 2;
}

abstract class GgmlTensorFlag {
  static const int GGML_TENSOR_FLAG_INPUT = 1;
  static const int GGML_TENSOR_FLAG_OUTPUT = 2;
  static const int GGML_TENSOR_FLAG_PARAM = 4;
}

/// NOTE: always add types at the end of the enum to keep backward compatibility
abstract class GgmlType {
  static const int GGML_TYPE_F32 = 0;
  static const int GGML_TYPE_F16 = 1;
  static const int GGML_TYPE_Q4_0 = 2;
  static const int GGML_TYPE_Q4_1 = 3;

  /// GGML_TYPE_Q4_2 = 4, support has been removed
  /// GGML_TYPE_Q4_3 = 5, support has been removed
  static const int GGML_TYPE_Q5_0 = 6;
  static const int GGML_TYPE_Q5_1 = 7;
  static const int GGML_TYPE_Q8_0 = 8;
  static const int GGML_TYPE_Q8_1 = 9;
  static const int GGML_TYPE_Q2_K = 10;
  static const int GGML_TYPE_Q3_K = 11;
  static const int GGML_TYPE_Q4_K = 12;
  static const int GGML_TYPE_Q5_K = 13;
  static const int GGML_TYPE_Q6_K = 14;
  static const int GGML_TYPE_Q8_K = 15;
  static const int GGML_TYPE_IQ2_XXS = 16;
  static const int GGML_TYPE_IQ2_XS = 17;
  static const int GGML_TYPE_IQ3_XXS = 18;
  static const int GGML_TYPE_IQ1_S = 19;
  static const int GGML_TYPE_IQ4_NL = 20;
  static const int GGML_TYPE_IQ3_S = 21;
  static const int GGML_TYPE_IQ2_S = 22;
  static const int GGML_TYPE_IQ4_XS = 23;
  static const int GGML_TYPE_I8 = 24;
  static const int GGML_TYPE_I16 = 25;
  static const int GGML_TYPE_I32 = 26;
  static const int GGML_TYPE_I64 = 27;
  static const int GGML_TYPE_F64 = 28;
  static const int GGML_TYPE_IQ1_M = 29;
  static const int GGML_TYPE_COUNT = 30;
}

abstract class GgmlUnaryOp {
  static const int GGML_UNARY_OP_ABS = 0;
  static const int GGML_UNARY_OP_SGN = 1;
  static const int GGML_UNARY_OP_NEG = 2;
  static const int GGML_UNARY_OP_STEP = 3;
  static const int GGML_UNARY_OP_TANH = 4;
  static const int GGML_UNARY_OP_ELU = 5;
  static const int GGML_UNARY_OP_RELU = 6;
  static const int GGML_UNARY_OP_GELU = 7;
  static const int GGML_UNARY_OP_GELU_QUICK = 8;
  static const int GGML_UNARY_OP_SILU = 9;
  static const int GGML_UNARY_OP_HARDSWISH = 10;
  static const int GGML_UNARY_OP_HARDSIGMOID = 11;
  static const int GGML_UNARY_OP_COUNT = 12;
}

/// gguf
abstract class GgufType {
  static const int GGUF_TYPE_UINT8 = 0;
  static const int GGUF_TYPE_INT8 = 1;
  static const int GGUF_TYPE_UINT16 = 2;
  static const int GGUF_TYPE_INT16 = 3;
  static const int GGUF_TYPE_UINT32 = 4;
  static const int GGUF_TYPE_INT32 = 5;
  static const int GGUF_TYPE_FLOAT32 = 6;
  static const int GGUF_TYPE_BOOL = 7;
  static const int GGUF_TYPE_STRING = 8;
  static const int GGUF_TYPE_ARRAY = 9;
  static const int GGUF_TYPE_UINT64 = 10;
  static const int GGUF_TYPE_INT64 = 11;
  static const int GGUF_TYPE_FLOAT64 = 12;

  /// marks the end of the enum
  static const int GGUF_TYPE_COUNT = 13;
}

/// ADAM parameters
final class UnnamedStruct1 extends ffi.Struct {
  @ffi.Int()
  external int n_iter;

  /// schedule multiplier (fixed, decay or warmup)
  @ffi.Float()
  external double sched;

  /// weight decay for AdamW, use 0.0f to disable
  @ffi.Float()
  external double decay;

  /// minimum number of tensor dimension to apply weight decay
  @ffi.Int()
  external int decay_min_ndim;

  /// learning rate
  @ffi.Float()
  external double alpha;

  @ffi.Float()
  external double beta1;

  @ffi.Float()
  external double beta2;

  /// epsilon for numerical stability
  @ffi.Float()
  external double eps;

  /// epsilon for convergence test
  @ffi.Float()
  external double eps_f;

  /// epsilon for convergence test
  @ffi.Float()
  external double eps_g;

  /// gradient clipping
  @ffi.Float()
  external double gclip;
}

/// LBFGS parameters
final class UnnamedStruct2 extends ffi.Struct {
  /// number of corrections to approximate the inv. Hessian
  @ffi.Int()
  external int m;

  @ffi.Int()
  external int n_iter;

  @ffi.Int()
  external int max_linesearch;

  /// convergence tolerance
  @ffi.Float()
  external double eps;

  /// line search tolerance
  @ffi.Float()
  external double ftol;

  @ffi.Float()
  external double wolfe;

  @ffi.Float()
  external double min_step;

  @ffi.Float()
  external double max_step;

  @ffi.Int32()
  external int linesearch;
}

final class UnnamedStruct3 extends ffi.Struct {
  /// current gradient
  external ffi.Pointer<ggml_tensor> g;

  /// first moment
  external ffi.Pointer<ggml_tensor> m;

  /// second moment
  external ffi.Pointer<ggml_tensor> v;

  /// past function values
  external ffi.Pointer<ggml_tensor> pf;

  @ffi.Float()
  external double fx_best;

  @ffi.Float()
  external double fx_prev;

  @ffi.Int()
  external int n_no_improvement;
}

final class UnnamedStruct4 extends ffi.Struct {
  /// current parameters
  external ffi.Pointer<ggml_tensor> x;

  /// previous parameters
  external ffi.Pointer<ggml_tensor> xp;

  /// current gradient
  external ffi.Pointer<ggml_tensor> g;

  /// previous gradient
  external ffi.Pointer<ggml_tensor> gp;

  /// search direction
  external ffi.Pointer<ggml_tensor> d;

  /// past function values
  external ffi.Pointer<ggml_tensor> pf;

  /// the L-BFGS memory alpha
  external ffi.Pointer<ggml_tensor> lmal;

  /// the L-BFGS memory ys
  external ffi.Pointer<ggml_tensor> lmys;

  /// the L-BFGS memory s
  external ffi.Pointer<ggml_tensor> lms;

  /// the L-BFGS memory y
  external ffi.Pointer<ggml_tensor> lmy;

  @ffi.Float()
  external double fx_best;

  @ffi.Float()
  external double step;

  @ffi.Int()
  external int j;

  @ffi.Int()
  external int k;

  @ffi.Int()
  external int end;

  @ffi.Int()
  external int n_no_improvement;
}

final class _iobuf extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _Placeholder;
}

/// Abort callback
/// If not NULL, called before ggml computation
/// If it returns true, the computation is aborted
typedef ggml_abort_callback
    = ffi.Pointer<ffi.NativeFunction<ggml_abort_callbackFunction>>;
typedef ggml_abort_callbackFunction = ffi.Bool Function(
    ffi.Pointer<ffi.Void> data);
typedef Dartggml_abort_callbackFunction = bool Function(
    ffi.Pointer<ffi.Void> data);

final class ggml_backend extends ffi.Opaque {}

final class ggml_backend_buffer extends ffi.Opaque {}

typedef ggml_backend_buffer_t = ffi.Pointer<ggml_backend_buffer>;

final class ggml_backend_buffer_type extends ffi.Opaque {}

typedef ggml_backend_buffer_type_t = ffi.Pointer<ggml_backend_buffer_type>;
typedef ggml_backend_eval_callback
    = ffi.Pointer<ffi.NativeFunction<ggml_backend_eval_callbackFunction>>;
typedef ggml_backend_eval_callbackFunction = ffi.Bool Function(
    ffi.Int node_index,
    ffi.Pointer<ggml_tensor> t1,
    ffi.Pointer<ggml_tensor> t2,
    ffi.Pointer<ffi.Void> user_data);
typedef Dartggml_backend_eval_callbackFunction = bool Function(
    int node_index,
    ffi.Pointer<ggml_tensor> t1,
    ffi.Pointer<ggml_tensor> t2,
    ffi.Pointer<ffi.Void> user_data);

final class ggml_backend_event extends ffi.Opaque {}

typedef ggml_backend_event_t = ffi.Pointer<ggml_backend_event>;

/// Utils
final class ggml_backend_graph_copy extends ffi.Struct {
  external ggml_backend_buffer_t buffer;

  external ffi.Pointer<ggml_context> ctx_allocated;

  external ffi.Pointer<ggml_context> ctx_unallocated;

  external ffi.Pointer<ggml_cgraph> graph;
}

typedef ggml_backend_graph_plan_t = ffi.Pointer<ffi.Void>;

/// The backend scheduler allows for multiple backends to be used together
/// Handles compute buffer allocation, assignment of tensors to backends, and copying of tensors between backends
/// The backends are selected based on:
/// - the backend that supports the operation
/// - the location of the pre-allocated tensors (e.g. the weights)
///     /*
///       Example usage:
///
/// operations that use tensors allocated in a buffer with USAGE_WEIGHTS will be assigned
/// preferrably to run on the same backend as the buffer
///         ggml_backend_buffer_set_usage(buf_weights, GGML_BACKEND_BUFFER_USAGE_WEIGHTS);
///
///         sched = ggml_backend_sched_new({backend_gpu, backend_gpu2, backend_cpu}, NULL, num_backends, GGML_DEFAULT_GRAPH_SIZE, false);
///
/// initialize buffers from a max size graph (optional)
///         reserve_graph = build_graph(sched, max_batch_size);
///
/// manually assign nodes to a backend (optional, should not be needed in most cases)
///         struct ggml_tensor * node = ggml_mul_mat(ctx, ...);
///         ggml_backend_sched_set_tensor_backend(sched, node, backend_gpu);
///
///         ggml_backend_sched_reserve(sched, reserve_graph);
///
/// compute
///         graph = build_graph(sched);
///         ggml_backend_sched_graph_compute(sched, graph);
///
/// if there are graph inputs:
///         ggml_backend_sched_reset(sched);
///         ggml_backend_sched_alloc_graph(sched, graph);
///         ggml_backend_tensor_set(input_tensor, ...);
///         ggml_backend_sched_graph_compute(sched, graph);
///     }
///     */
final class ggml_backend_sched extends ffi.Opaque {}

/// when ask == true, the scheduler wants to know if the user wants to observe this node
/// this allows the scheduler to batch nodes together in order to evaluate them in a single call
///
/// when ask == false, the scheduler is passing the node tensor to the user for observation
/// if the user returns false, the scheduler will cancel the graph compute
typedef ggml_backend_sched_eval_callback
    = ffi.Pointer<ffi.NativeFunction<ggml_backend_sched_eval_callbackFunction>>;
typedef ggml_backend_sched_eval_callbackFunction = ffi.Bool Function(
    ffi.Pointer<ggml_tensor> t, ffi.Bool ask, ffi.Pointer<ffi.Void> user_data);
typedef Dartggml_backend_sched_eval_callbackFunction = bool Function(
    ffi.Pointer<ggml_tensor> t, bool ask, ffi.Pointer<ffi.Void> user_data);
typedef ggml_backend_sched_t = ffi.Pointer<ggml_backend_sched>;
typedef ggml_backend_t = ffi.Pointer<ggml_backend>;
typedef ggml_binary_op_f32_t
    = ffi.Pointer<ffi.NativeFunction<ggml_binary_op_f32_tFunction>>;
typedef ggml_binary_op_f32_tFunction = ffi.Void Function(ffi.Int,
    ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>);
typedef Dartggml_binary_op_f32_tFunction = void Function(int,
    ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>);

/// computation graph
final class ggml_cgraph extends ffi.Struct {
  @ffi.Int()
  external int size;

  @ffi.Int()
  external int n_nodes;

  @ffi.Int()
  external int n_leafs;

  external ffi.Pointer<ffi.Pointer<ggml_tensor>> nodes;

  external ffi.Pointer<ffi.Pointer<ggml_tensor>> grads;

  external ffi.Pointer<ffi.Pointer<ggml_tensor>> leafs;

  external ggml_hash_set visited_hash_table;

  @ffi.Int32()
  external int order;

  /// performance
  @ffi.Int()
  external int perf_runs;

  @ffi.Int64()
  external int perf_cycles;

  @ffi.Int64()
  external int perf_time_us;
}

final class ggml_compute_params extends ffi.Struct {
  @ffi.Int32()
  external int type;

  /// ith = thread index, nth = number of threads
  @ffi.Int()
  external int ith;

  @ffi.Int()
  external int nth;

  /// work buffer for all threads
  @ffi.Size()
  external int wsize;

  external ffi.Pointer<ffi.Void> wdata;
}

final class ggml_context extends ffi.Opaque {}

/// the compute plan that needs to be prepared for ggml_graph_compute()
/// since https://github.com/ggerganov/ggml/issues/287
final class ggml_cplan extends ffi.Struct {
  /// size of work buffer, calculated by `ggml_graph_plan()`
  @ffi.Size()
  external int work_size;

  /// work buffer, to be allocated by caller before calling to `ggml_graph_compute()`
  external ffi.Pointer<ffi.Uint8> work_data;

  @ffi.Int()
  external int n_threads;

  /// abort ggml_graph_compute when true
  external ggml_abort_callback abort_callback;

  external ffi.Pointer<ffi.Void> abort_callback_data;
}

typedef ggml_custom1_op_f32_t
    = ffi.Pointer<ffi.NativeFunction<ggml_custom1_op_f32_tFunction>>;
typedef ggml_custom1_op_f32_tFunction = ffi.Void Function(
    ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>);
typedef Dartggml_custom1_op_f32_tFunction = void Function(
    ffi.Pointer<ggml_tensor>, ffi.Pointer<ggml_tensor>);

/// custom operators v2
typedef ggml_custom1_op_t
    = ffi.Pointer<ffi.NativeFunction<ggml_custom1_op_tFunction>>;
typedef ggml_custom1_op_tFunction = ffi.Void Function(
    ffi.Pointer<ggml_tensor> dst,
    ffi.Pointer<ggml_tensor> a,
    ffi.Int ith,
    ffi.Int nth,
    ffi.Pointer<ffi.Void> userdata);
typedef Dartggml_custom1_op_tFunction = void Function(
    ffi.Pointer<ggml_tensor> dst,
    ffi.Pointer<ggml_tensor> a,
    int ith,
    int nth,
    ffi.Pointer<ffi.Void> userdata);
typedef ggml_custom2_op_f32_t
    = ffi.Pointer<ffi.NativeFunction<ggml_custom2_op_f32_tFunction>>;
typedef ggml_custom2_op_f32_tFunction = ffi.Void Function(
    ffi.Pointer<ggml_tensor>,
    ffi.Pointer<ggml_tensor>,
    ffi.Pointer<ggml_tensor>);
typedef Dartggml_custom2_op_f32_tFunction = void Function(
    ffi.Pointer<ggml_tensor>,
    ffi.Pointer<ggml_tensor>,
    ffi.Pointer<ggml_tensor>);
typedef ggml_custom2_op_t
    = ffi.Pointer<ffi.NativeFunction<ggml_custom2_op_tFunction>>;
typedef ggml_custom2_op_tFunction = ffi.Void Function(
    ffi.Pointer<ggml_tensor> dst,
    ffi.Pointer<ggml_tensor> a,
    ffi.Pointer<ggml_tensor> b,
    ffi.Int ith,
    ffi.Int nth,
    ffi.Pointer<ffi.Void> userdata);
typedef Dartggml_custom2_op_tFunction = void Function(
    ffi.Pointer<ggml_tensor> dst,
    ffi.Pointer<ggml_tensor> a,
    ffi.Pointer<ggml_tensor> b,
    int ith,
    int nth,
    ffi.Pointer<ffi.Void> userdata);
typedef ggml_custom3_op_f32_t
    = ffi.Pointer<ffi.NativeFunction<ggml_custom3_op_f32_tFunction>>;
typedef ggml_custom3_op_f32_tFunction = ffi.Void Function(
    ffi.Pointer<ggml_tensor>,
    ffi.Pointer<ggml_tensor>,
    ffi.Pointer<ggml_tensor>,
    ffi.Pointer<ggml_tensor>);
typedef Dartggml_custom3_op_f32_tFunction = void Function(
    ffi.Pointer<ggml_tensor>,
    ffi.Pointer<ggml_tensor>,
    ffi.Pointer<ggml_tensor>,
    ffi.Pointer<ggml_tensor>);
typedef ggml_custom3_op_t
    = ffi.Pointer<ffi.NativeFunction<ggml_custom3_op_tFunction>>;
typedef ggml_custom3_op_tFunction = ffi.Void Function(
    ffi.Pointer<ggml_tensor> dst,
    ffi.Pointer<ggml_tensor> a,
    ffi.Pointer<ggml_tensor> b,
    ffi.Pointer<ggml_tensor> c,
    ffi.Int ith,
    ffi.Int nth,
    ffi.Pointer<ffi.Void> userdata);
typedef Dartggml_custom3_op_tFunction = void Function(
    ffi.Pointer<ggml_tensor> dst,
    ffi.Pointer<ggml_tensor> a,
    ffi.Pointer<ggml_tensor> b,
    ffi.Pointer<ggml_tensor> c,
    int ith,
    int nth,
    ffi.Pointer<ffi.Void> userdata);
typedef ggml_fp16_t = ffi.Uint16;
typedef Dartggml_fp16_t = int;
typedef ggml_from_float_t
    = ffi.Pointer<ffi.NativeFunction<ggml_from_float_tFunction>>;
typedef ggml_from_float_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Float> x, ffi.Pointer<ffi.Void> y, ffi.Int64 k);
typedef Dartggml_from_float_tFunction = void Function(
    ffi.Pointer<ffi.Float> x, ffi.Pointer<ffi.Void> y, int k);

final class ggml_gallocr extends ffi.Opaque {}

/// special tensor flags for use with the graph allocator:
/// ggml_set_input(): all input tensors are allocated at the beginning of the graph in non-overlapping addresses
/// ggml_set_output(): output tensors are never freed and never overwritten
typedef ggml_gallocr_t = ffi.Pointer<ggml_gallocr>;
typedef ggml_guid_t = ffi.Pointer<ffi.Pointer<ffi.Uint8>>;

final class ggml_hash_set extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Pointer<ggml_tensor>> keys;
}

final class ggml_init_params extends ffi.Struct {
  /// bytes
  @ffi.Size()
  external int mem_size;

  /// if NULL, memory will be allocated internally
  external ffi.Pointer<ffi.Void> mem_buffer;

  /// don't allocate memory for the tensor data
  @ffi.Bool()
  external bool no_alloc;
}

/// ggml object
final class ggml_object extends ffi.Struct {
  @ffi.Size()
  external int offs;

  @ffi.Size()
  external int size;

  external ffi.Pointer<ggml_object> next;

  @ffi.Int32()
  external int type;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> padding;
}

typedef ggml_opt_callback
    = ffi.Pointer<ffi.NativeFunction<ggml_opt_callbackFunction>>;
typedef ggml_opt_callbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> data,
    ffi.Int accum_step,
    ffi.Pointer<ffi.Float> sched,
    ffi.Pointer<ffi.Bool> cancel);
typedef Dartggml_opt_callbackFunction = void Function(
    ffi.Pointer<ffi.Void> data,
    int accum_step,
    ffi.Pointer<ffi.Float> sched,
    ffi.Pointer<ffi.Bool> cancel);

final class ggml_opt_context extends ffi.Struct {
  external ffi.Pointer<ggml_context> ctx;

  external ggml_opt_params params;

  @ffi.Int()
  external int iter;

  /// number of parameter elements
  @ffi.Int64()
  external int nx;

  @ffi.Bool()
  external bool just_initialized;

  @ffi.Float()
  external double loss_before;

  @ffi.Float()
  external double loss_after;

  external UnnamedStruct3 adam;

  external UnnamedStruct4 lbfgs;
}

/// optimization parameters
///
/// see ggml.c (ggml_opt_default_params) for default values
final class ggml_opt_params extends ffi.Struct {
  @ffi.Int32()
  external int type;

  @ffi.Size()
  external int graph_size;

  @ffi.Int()
  external int n_threads;

  /// delta-based convergence test
  ///
  /// if past == 0 - disabled
  /// if past > 0:
  /// stop if |f(x) - f(x_past)| < delta * max(1, |f(x)|)
  @ffi.Int()
  external int past;

  @ffi.Float()
  external double delta;

  /// maximum number of iterations without improvement
  ///
  /// if 0 - disabled
  /// if > 0:
  /// assume convergence if no cost improvement in this number of iterations
  @ffi.Int()
  external int max_no_improvement;

  @ffi.Bool()
  external bool print_forward_graph;

  @ffi.Bool()
  external bool print_backward_graph;

  @ffi.Int()
  external int n_gradient_accumulation;

  external UnnamedStruct1 adam;

  external UnnamedStruct2 lbfgs;
}

/// scratch buffer
final class ggml_scratch extends ffi.Struct {
  @ffi.Size()
  external int offs;

  @ffi.Size()
  external int size;

  external ffi.Pointer<ffi.Void> data;
}

/// Tensor allocator
final class ggml_tallocr extends ffi.Struct {
  external ggml_backend_buffer_t buffer;

  external ffi.Pointer<ffi.Void> base;

  @ffi.Size()
  external int alignment;

  @ffi.Size()
  external int offset;
}

/// n-dimensional tensor
final class ggml_tensor extends ffi.Struct {
  @ffi.Int32()
  external int type;

  @ffi.Int32()
  external int backend;

  external ffi.Pointer<ggml_backend_buffer> buffer;

  /// number of elements
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Int64> ne;

  /// stride in bytes:
  /// nb[0] = ggml_type_size(type)
  /// nb[1] = nb[0]   * (ne[0] / ggml_blck_size(type)) + padding
  /// nb[i] = nb[i-1] * ne[i-1]
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Size> nb;

  /// compute data
  @ffi.Int32()
  external int op;

  /// op params - allocated as int32_t for alignment
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Int32> op_params;

  @ffi.Int32()
  external int flags;

  external ffi.Pointer<ggml_tensor> grad;

  @ffi.Array.multi([10])
  external ffi.Array<ffi.Pointer<ggml_tensor>> src;

  /// performance
  @ffi.Int()
  external int perf_runs;

  @ffi.Int64()
  external int perf_cycles;

  @ffi.Int64()
  external int perf_time_us;

  external ffi.Pointer<ggml_tensor> view_src;

  @ffi.Size()
  external int view_offs;

  external ffi.Pointer<ffi.Void> data;

  @ffi.Array.multi([64])
  external ffi.Array<ffi.Char> name;

  /// extra things e.g. for ggml-cuda.cu
  external ffi.Pointer<ffi.Void> extra;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> padding;
}

typedef ggml_to_float_t
    = ffi.Pointer<ffi.NativeFunction<ggml_to_float_tFunction>>;
typedef ggml_to_float_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> x, ffi.Pointer<ffi.Float> y, ffi.Int64 k);
typedef Dartggml_to_float_tFunction = void Function(
    ffi.Pointer<ffi.Void> x, ffi.Pointer<ffi.Float> y, int k);

final class ggml_type_traits_t extends ffi.Struct {
  external ffi.Pointer<ffi.Char> type_name;

  @ffi.Int()
  external int blck_size;

  @ffi.Size()
  external int type_size;

  @ffi.Bool()
  external bool is_quantized;

  external ggml_to_float_t to_float;

  external ggml_from_float_t from_float;

  external ggml_from_float_t from_float_reference;

  external ggml_vec_dot_t vec_dot;

  @ffi.Int32()
  external int vec_dot_type;

  /// number of rows to process simultaneously;
  @ffi.Int64()
  external int nrows;
}

/// custom operators
typedef ggml_unary_op_f32_t
    = ffi.Pointer<ffi.NativeFunction<ggml_unary_op_f32_tFunction>>;
typedef ggml_unary_op_f32_tFunction = ffi.Void Function(
    ffi.Int, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>);
typedef Dartggml_unary_op_f32_tFunction = void Function(
    int, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>);
typedef ggml_vec_dot_t
    = ffi.Pointer<ffi.NativeFunction<ggml_vec_dot_tFunction>>;
typedef ggml_vec_dot_tFunction = ffi.Void Function(
    ffi.Int n,
    ffi.Pointer<ffi.Float> s,
    ffi.Size bs,
    ffi.Pointer<ffi.Void> x,
    ffi.Size bx,
    ffi.Pointer<ffi.Void> y,
    ffi.Size by,
    ffi.Int nrc);
typedef Dartggml_vec_dot_tFunction = void Function(
    int n,
    ffi.Pointer<ffi.Float> s,
    int bs,
    ffi.Pointer<ffi.Void> x,
    int bx,
    ffi.Pointer<ffi.Void> y,
    int by,
    int nrc);

final class gguf_context extends ffi.Opaque {}

final class gguf_init_params extends ffi.Struct {
  @ffi.Bool()
  external bool no_alloc;

  /// if not NULL, create a ggml_context and allocate the tensor data in it
  external ffi.Pointer<ffi.Pointer<ggml_context>> ctx;
}
